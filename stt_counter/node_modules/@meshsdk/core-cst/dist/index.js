var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// ../../node_modules/blakejs/util.js
var require_util = __commonJS({
  "../../node_modules/blakejs/util.js"(exports, module) {
    "use strict";
    var ERROR_MSG_INPUT = "Input must be an string, Buffer or Uint8Array";
    function normalizeInput(input) {
      let ret;
      if (input instanceof Uint8Array) {
        ret = input;
      } else if (typeof input === "string") {
        const encoder = new TextEncoder();
        ret = encoder.encode(input);
      } else {
        throw new Error(ERROR_MSG_INPUT);
      }
      return ret;
    }
    function toHex(bytes) {
      return Array.prototype.map.call(bytes, function(n) {
        return (n < 16 ? "0" : "") + n.toString(16);
      }).join("");
    }
    function uint32ToHex(val) {
      return (4294967296 + val).toString(16).substring(1);
    }
    function debugPrint(label, arr, size) {
      let msg = "\n" + label + " = ";
      for (let i = 0; i < arr.length; i += 2) {
        if (size === 32) {
          msg += uint32ToHex(arr[i]).toUpperCase();
          msg += " ";
          msg += uint32ToHex(arr[i + 1]).toUpperCase();
        } else if (size === 64) {
          msg += uint32ToHex(arr[i + 1]).toUpperCase();
          msg += uint32ToHex(arr[i]).toUpperCase();
        } else throw new Error("Invalid size " + size);
        if (i % 6 === 4) {
          msg += "\n" + new Array(label.length + 4).join(" ");
        } else if (i < arr.length - 2) {
          msg += " ";
        }
      }
      console.log(msg);
    }
    function testSpeed(hashFn, N, M) {
      let startMs = (/* @__PURE__ */ new Date()).getTime();
      const input = new Uint8Array(N);
      for (let i = 0; i < N; i++) {
        input[i] = i % 256;
      }
      const genMs = (/* @__PURE__ */ new Date()).getTime();
      console.log("Generated random input in " + (genMs - startMs) + "ms");
      startMs = genMs;
      for (let i = 0; i < M; i++) {
        const hashHex = hashFn(input);
        const hashMs = (/* @__PURE__ */ new Date()).getTime();
        const ms = hashMs - startMs;
        startMs = hashMs;
        console.log("Hashed in " + ms + "ms: " + hashHex.substring(0, 20) + "...");
        console.log(
          Math.round(N / (1 << 20) / (ms / 1e3) * 100) / 100 + " MB PER SECOND"
        );
      }
    }
    module.exports = {
      normalizeInput,
      toHex,
      debugPrint,
      testSpeed
    };
  }
});

// ../../node_modules/blakejs/blake2b.js
var require_blake2b = __commonJS({
  "../../node_modules/blakejs/blake2b.js"(exports, module) {
    "use strict";
    var util = require_util();
    function ADD64AA(v2, a, b) {
      const o0 = v2[a] + v2[b];
      let o1 = v2[a + 1] + v2[b + 1];
      if (o0 >= 4294967296) {
        o1++;
      }
      v2[a] = o0;
      v2[a + 1] = o1;
    }
    function ADD64AC(v2, a, b0, b1) {
      let o0 = v2[a] + b0;
      if (b0 < 0) {
        o0 += 4294967296;
      }
      let o1 = v2[a + 1] + b1;
      if (o0 >= 4294967296) {
        o1++;
      }
      v2[a] = o0;
      v2[a + 1] = o1;
    }
    function B2B_GET32(arr, i) {
      return arr[i] ^ arr[i + 1] << 8 ^ arr[i + 2] << 16 ^ arr[i + 3] << 24;
    }
    function B2B_G(a, b, c, d, ix, iy) {
      const x0 = m[ix];
      const x1 = m[ix + 1];
      const y0 = m[iy];
      const y1 = m[iy + 1];
      ADD64AA(v, a, b);
      ADD64AC(v, a, x0, x1);
      let xor0 = v[d] ^ v[a];
      let xor1 = v[d + 1] ^ v[a + 1];
      v[d] = xor1;
      v[d + 1] = xor0;
      ADD64AA(v, c, d);
      xor0 = v[b] ^ v[c];
      xor1 = v[b + 1] ^ v[c + 1];
      v[b] = xor0 >>> 24 ^ xor1 << 8;
      v[b + 1] = xor1 >>> 24 ^ xor0 << 8;
      ADD64AA(v, a, b);
      ADD64AC(v, a, y0, y1);
      xor0 = v[d] ^ v[a];
      xor1 = v[d + 1] ^ v[a + 1];
      v[d] = xor0 >>> 16 ^ xor1 << 16;
      v[d + 1] = xor1 >>> 16 ^ xor0 << 16;
      ADD64AA(v, c, d);
      xor0 = v[b] ^ v[c];
      xor1 = v[b + 1] ^ v[c + 1];
      v[b] = xor1 >>> 31 ^ xor0 << 1;
      v[b + 1] = xor0 >>> 31 ^ xor1 << 1;
    }
    var BLAKE2B_IV32 = new Uint32Array([
      4089235720,
      1779033703,
      2227873595,
      3144134277,
      4271175723,
      1013904242,
      1595750129,
      2773480762,
      2917565137,
      1359893119,
      725511199,
      2600822924,
      4215389547,
      528734635,
      327033209,
      1541459225
    ]);
    var SIGMA8 = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      14,
      10,
      4,
      8,
      9,
      15,
      13,
      6,
      1,
      12,
      0,
      2,
      11,
      7,
      5,
      3,
      11,
      8,
      12,
      0,
      5,
      2,
      15,
      13,
      10,
      14,
      3,
      6,
      7,
      1,
      9,
      4,
      7,
      9,
      3,
      1,
      13,
      12,
      11,
      14,
      2,
      6,
      5,
      10,
      4,
      0,
      15,
      8,
      9,
      0,
      5,
      7,
      2,
      4,
      10,
      15,
      14,
      1,
      11,
      12,
      6,
      8,
      3,
      13,
      2,
      12,
      6,
      10,
      0,
      11,
      8,
      3,
      4,
      13,
      7,
      5,
      15,
      14,
      1,
      9,
      12,
      5,
      1,
      15,
      14,
      13,
      4,
      10,
      0,
      7,
      6,
      3,
      9,
      2,
      8,
      11,
      13,
      11,
      7,
      14,
      12,
      1,
      3,
      9,
      5,
      0,
      15,
      4,
      8,
      6,
      2,
      10,
      6,
      15,
      14,
      9,
      11,
      3,
      0,
      8,
      12,
      2,
      13,
      7,
      1,
      4,
      10,
      5,
      10,
      2,
      8,
      4,
      7,
      6,
      1,
      5,
      15,
      11,
      9,
      14,
      3,
      12,
      13,
      0,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      14,
      10,
      4,
      8,
      9,
      15,
      13,
      6,
      1,
      12,
      0,
      2,
      11,
      7,
      5,
      3
    ];
    var SIGMA82 = new Uint8Array(
      SIGMA8.map(function(x) {
        return x * 2;
      })
    );
    var v = new Uint32Array(32);
    var m = new Uint32Array(32);
    function blake2bCompress(ctx, last) {
      let i = 0;
      for (i = 0; i < 16; i++) {
        v[i] = ctx.h[i];
        v[i + 16] = BLAKE2B_IV32[i];
      }
      v[24] = v[24] ^ ctx.t;
      v[25] = v[25] ^ ctx.t / 4294967296;
      if (last) {
        v[28] = ~v[28];
        v[29] = ~v[29];
      }
      for (i = 0; i < 32; i++) {
        m[i] = B2B_GET32(ctx.b, 4 * i);
      }
      for (i = 0; i < 12; i++) {
        B2B_G(0, 8, 16, 24, SIGMA82[i * 16 + 0], SIGMA82[i * 16 + 1]);
        B2B_G(2, 10, 18, 26, SIGMA82[i * 16 + 2], SIGMA82[i * 16 + 3]);
        B2B_G(4, 12, 20, 28, SIGMA82[i * 16 + 4], SIGMA82[i * 16 + 5]);
        B2B_G(6, 14, 22, 30, SIGMA82[i * 16 + 6], SIGMA82[i * 16 + 7]);
        B2B_G(0, 10, 20, 30, SIGMA82[i * 16 + 8], SIGMA82[i * 16 + 9]);
        B2B_G(2, 12, 22, 24, SIGMA82[i * 16 + 10], SIGMA82[i * 16 + 11]);
        B2B_G(4, 14, 16, 26, SIGMA82[i * 16 + 12], SIGMA82[i * 16 + 13]);
        B2B_G(6, 8, 18, 28, SIGMA82[i * 16 + 14], SIGMA82[i * 16 + 15]);
      }
      for (i = 0; i < 16; i++) {
        ctx.h[i] = ctx.h[i] ^ v[i] ^ v[i + 16];
      }
    }
    var parameterBlock = new Uint8Array([
      0,
      0,
      0,
      0,
      //  0: outlen, keylen, fanout, depth
      0,
      0,
      0,
      0,
      //  4: leaf length, sequential mode
      0,
      0,
      0,
      0,
      //  8: node offset
      0,
      0,
      0,
      0,
      // 12: node offset
      0,
      0,
      0,
      0,
      // 16: node depth, inner length, rfu
      0,
      0,
      0,
      0,
      // 20: rfu
      0,
      0,
      0,
      0,
      // 24: rfu
      0,
      0,
      0,
      0,
      // 28: rfu
      0,
      0,
      0,
      0,
      // 32: salt
      0,
      0,
      0,
      0,
      // 36: salt
      0,
      0,
      0,
      0,
      // 40: salt
      0,
      0,
      0,
      0,
      // 44: salt
      0,
      0,
      0,
      0,
      // 48: personal
      0,
      0,
      0,
      0,
      // 52: personal
      0,
      0,
      0,
      0,
      // 56: personal
      0,
      0,
      0,
      0
      // 60: personal
    ]);
    function blake2bInit(outlen, key, salt, personal) {
      if (outlen === 0 || outlen > 64) {
        throw new Error("Illegal output length, expected 0 < length <= 64");
      }
      if (key && key.length > 64) {
        throw new Error("Illegal key, expected Uint8Array with 0 < length <= 64");
      }
      if (salt && salt.length !== 16) {
        throw new Error("Illegal salt, expected Uint8Array with length is 16");
      }
      if (personal && personal.length !== 16) {
        throw new Error("Illegal personal, expected Uint8Array with length is 16");
      }
      const ctx = {
        b: new Uint8Array(128),
        h: new Uint32Array(16),
        t: 0,
        // input count
        c: 0,
        // pointer within buffer
        outlen
        // output length in bytes
      };
      parameterBlock.fill(0);
      parameterBlock[0] = outlen;
      if (key) parameterBlock[1] = key.length;
      parameterBlock[2] = 1;
      parameterBlock[3] = 1;
      if (salt) parameterBlock.set(salt, 32);
      if (personal) parameterBlock.set(personal, 48);
      for (let i = 0; i < 16; i++) {
        ctx.h[i] = BLAKE2B_IV32[i] ^ B2B_GET32(parameterBlock, i * 4);
      }
      if (key) {
        blake2bUpdate(ctx, key);
        ctx.c = 128;
      }
      return ctx;
    }
    function blake2bUpdate(ctx, input) {
      for (let i = 0; i < input.length; i++) {
        if (ctx.c === 128) {
          ctx.t += ctx.c;
          blake2bCompress(ctx, false);
          ctx.c = 0;
        }
        ctx.b[ctx.c++] = input[i];
      }
    }
    function blake2bFinal(ctx) {
      ctx.t += ctx.c;
      while (ctx.c < 128) {
        ctx.b[ctx.c++] = 0;
      }
      blake2bCompress(ctx, true);
      const out = new Uint8Array(ctx.outlen);
      for (let i = 0; i < ctx.outlen; i++) {
        out[i] = ctx.h[i >> 2] >> 8 * (i & 3);
      }
      return out;
    }
    function blake2b7(input, key, outlen, salt, personal) {
      outlen = outlen || 64;
      input = util.normalizeInput(input);
      if (salt) {
        salt = util.normalizeInput(salt);
      }
      if (personal) {
        personal = util.normalizeInput(personal);
      }
      const ctx = blake2bInit(outlen, key, salt, personal);
      blake2bUpdate(ctx, input);
      return blake2bFinal(ctx);
    }
    function blake2bHex(input, key, outlen, salt, personal) {
      const output = blake2b7(input, key, outlen, salt, personal);
      return util.toHex(output);
    }
    module.exports = {
      blake2b: blake2b7,
      blake2bHex,
      blake2bInit,
      blake2bUpdate,
      blake2bFinal
    };
  }
});

// ../../node_modules/blakejs/blake2s.js
var require_blake2s = __commonJS({
  "../../node_modules/blakejs/blake2s.js"(exports, module) {
    "use strict";
    var util = require_util();
    function B2S_GET32(v2, i) {
      return v2[i] ^ v2[i + 1] << 8 ^ v2[i + 2] << 16 ^ v2[i + 3] << 24;
    }
    function B2S_G(a, b, c, d, x, y) {
      v[a] = v[a] + v[b] + x;
      v[d] = ROTR32(v[d] ^ v[a], 16);
      v[c] = v[c] + v[d];
      v[b] = ROTR32(v[b] ^ v[c], 12);
      v[a] = v[a] + v[b] + y;
      v[d] = ROTR32(v[d] ^ v[a], 8);
      v[c] = v[c] + v[d];
      v[b] = ROTR32(v[b] ^ v[c], 7);
    }
    function ROTR32(x, y) {
      return x >>> y ^ x << 32 - y;
    }
    var BLAKE2S_IV = new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    var SIGMA = new Uint8Array([
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      14,
      10,
      4,
      8,
      9,
      15,
      13,
      6,
      1,
      12,
      0,
      2,
      11,
      7,
      5,
      3,
      11,
      8,
      12,
      0,
      5,
      2,
      15,
      13,
      10,
      14,
      3,
      6,
      7,
      1,
      9,
      4,
      7,
      9,
      3,
      1,
      13,
      12,
      11,
      14,
      2,
      6,
      5,
      10,
      4,
      0,
      15,
      8,
      9,
      0,
      5,
      7,
      2,
      4,
      10,
      15,
      14,
      1,
      11,
      12,
      6,
      8,
      3,
      13,
      2,
      12,
      6,
      10,
      0,
      11,
      8,
      3,
      4,
      13,
      7,
      5,
      15,
      14,
      1,
      9,
      12,
      5,
      1,
      15,
      14,
      13,
      4,
      10,
      0,
      7,
      6,
      3,
      9,
      2,
      8,
      11,
      13,
      11,
      7,
      14,
      12,
      1,
      3,
      9,
      5,
      0,
      15,
      4,
      8,
      6,
      2,
      10,
      6,
      15,
      14,
      9,
      11,
      3,
      0,
      8,
      12,
      2,
      13,
      7,
      1,
      4,
      10,
      5,
      10,
      2,
      8,
      4,
      7,
      6,
      1,
      5,
      15,
      11,
      9,
      14,
      3,
      12,
      13,
      0
    ]);
    var v = new Uint32Array(16);
    var m = new Uint32Array(16);
    function blake2sCompress(ctx, last) {
      let i = 0;
      for (i = 0; i < 8; i++) {
        v[i] = ctx.h[i];
        v[i + 8] = BLAKE2S_IV[i];
      }
      v[12] ^= ctx.t;
      v[13] ^= ctx.t / 4294967296;
      if (last) {
        v[14] = ~v[14];
      }
      for (i = 0; i < 16; i++) {
        m[i] = B2S_GET32(ctx.b, 4 * i);
      }
      for (i = 0; i < 10; i++) {
        B2S_G(0, 4, 8, 12, m[SIGMA[i * 16 + 0]], m[SIGMA[i * 16 + 1]]);
        B2S_G(1, 5, 9, 13, m[SIGMA[i * 16 + 2]], m[SIGMA[i * 16 + 3]]);
        B2S_G(2, 6, 10, 14, m[SIGMA[i * 16 + 4]], m[SIGMA[i * 16 + 5]]);
        B2S_G(3, 7, 11, 15, m[SIGMA[i * 16 + 6]], m[SIGMA[i * 16 + 7]]);
        B2S_G(0, 5, 10, 15, m[SIGMA[i * 16 + 8]], m[SIGMA[i * 16 + 9]]);
        B2S_G(1, 6, 11, 12, m[SIGMA[i * 16 + 10]], m[SIGMA[i * 16 + 11]]);
        B2S_G(2, 7, 8, 13, m[SIGMA[i * 16 + 12]], m[SIGMA[i * 16 + 13]]);
        B2S_G(3, 4, 9, 14, m[SIGMA[i * 16 + 14]], m[SIGMA[i * 16 + 15]]);
      }
      for (i = 0; i < 8; i++) {
        ctx.h[i] ^= v[i] ^ v[i + 8];
      }
    }
    function blake2sInit(outlen, key) {
      if (!(outlen > 0 && outlen <= 32)) {
        throw new Error("Incorrect output length, should be in [1, 32]");
      }
      const keylen = key ? key.length : 0;
      if (key && !(keylen > 0 && keylen <= 32)) {
        throw new Error("Incorrect key length, should be in [1, 32]");
      }
      const ctx = {
        h: new Uint32Array(BLAKE2S_IV),
        // hash state
        b: new Uint8Array(64),
        // input block
        c: 0,
        // pointer within block
        t: 0,
        // input count
        outlen
        // output length in bytes
      };
      ctx.h[0] ^= 16842752 ^ keylen << 8 ^ outlen;
      if (keylen > 0) {
        blake2sUpdate(ctx, key);
        ctx.c = 64;
      }
      return ctx;
    }
    function blake2sUpdate(ctx, input) {
      for (let i = 0; i < input.length; i++) {
        if (ctx.c === 64) {
          ctx.t += ctx.c;
          blake2sCompress(ctx, false);
          ctx.c = 0;
        }
        ctx.b[ctx.c++] = input[i];
      }
    }
    function blake2sFinal(ctx) {
      ctx.t += ctx.c;
      while (ctx.c < 64) {
        ctx.b[ctx.c++] = 0;
      }
      blake2sCompress(ctx, true);
      const out = new Uint8Array(ctx.outlen);
      for (let i = 0; i < ctx.outlen; i++) {
        out[i] = ctx.h[i >> 2] >> 8 * (i & 3) & 255;
      }
      return out;
    }
    function blake2s(input, key, outlen) {
      outlen = outlen || 32;
      input = util.normalizeInput(input);
      const ctx = blake2sInit(outlen, key);
      blake2sUpdate(ctx, input);
      return blake2sFinal(ctx);
    }
    function blake2sHex(input, key, outlen) {
      const output = blake2s(input, key, outlen);
      return util.toHex(output);
    }
    module.exports = {
      blake2s,
      blake2sHex,
      blake2sInit,
      blake2sUpdate,
      blake2sFinal
    };
  }
});

// ../../node_modules/blakejs/index.js
var require_blakejs = __commonJS({
  "../../node_modules/blakejs/index.js"(exports, module) {
    "use strict";
    var b2b = require_blake2b();
    var b2s = require_blake2s();
    module.exports = {
      blake2b: b2b.blake2b,
      blake2bHex: b2b.blake2bHex,
      blake2bInit: b2b.blake2bInit,
      blake2bUpdate: b2b.blake2bUpdate,
      blake2bFinal: b2b.blake2bFinal,
      blake2s: b2s.blake2s,
      blake2sHex: b2s.blake2sHex,
      blake2sInit: b2s.blake2sInit,
      blake2sUpdate: b2s.blake2sUpdate,
      blake2sFinal: b2s.blake2sFinal
    };
  }
});

// src/index.ts
import { Cardano as Cardano5, Serialization as Serialization7 } from "@cardano-sdk/core";

// src/types/cardano-sdk.ts
import { Cardano, Serialization } from "@cardano-sdk/core";
import * as Crypto from "@cardano-sdk/crypto";
import { typedHex } from "@cardano-sdk/util";
var Slot = Cardano.Slot;
var Value = Serialization.Value;
var Transaction = Serialization.Transaction;
var TransactionId = Cardano.TransactionId;
var TransactionBody = Serialization.TransactionBody;
var TransactionWitnessSet = Serialization.TransactionWitnessSet;
var AuxilliaryData = Serialization.AuxiliaryData;
var TransactionMetadatum = Serialization.TransactionMetadatum;
var MetadatumMap = Serialization.MetadatumMap;
var MetadatumList = Serialization.MetadatumList;
var TransactionUnspentOutput = Serialization.TransactionUnspentOutput;
var TransactionInput = Serialization.TransactionInput;
var TransactionOutput = Serialization.TransactionOutput;
var PlutusData = Serialization.PlutusData;
var PlutusList = Serialization.PlutusList;
var PlutusMap = Serialization.PlutusMap;
var Redeemers = Serialization.Redeemers;
var Redeemer = Serialization.Redeemer;
var RedeemerPurpose = Cardano.RedeemerPurpose;
var RedeemerTag = Serialization.RedeemerTag;
var Script = Serialization.Script;
var PolicyId = Cardano.PolicyId;
var AssetName = Cardano.AssetName;
var AssetId = Cardano.AssetId;
var ScriptHash = Crypto.Hash28ByteBase16;
var Address = Cardano.Address;
var RewardAddress = Cardano.RewardAddress;
var AddressType = Cardano.AddressType;
var BaseAddress = Cardano.BaseAddress;
var EnterpriseAddress = Cardano.EnterpriseAddress;
var PaymentAddress = Cardano.PaymentAddress;
var AssetFingerprint = Cardano.AssetFingerprint;
var Credential = Serialization.Credential;
var Ed25519PublicKeyHex2 = Crypto.Ed25519PublicKeyHex;
var Ed25519PrivateNormalKeyHex = (value) => typedHex(value, 64);
var Ed25519PrivateExtendedKeyHex = (value) => typedHex(value, 128);
var Ed25519KeyHash2 = Crypto.Ed25519KeyHash;
var Ed25519KeyHashHex2 = Crypto.Ed25519KeyHashHex;
var Hash28ByteBase162 = Crypto.Hash28ByteBase16;
var Hash32ByteBase162 = Crypto.Hash32ByteBase16;
var CredentialType = Cardano.CredentialType;
var Certificate = Serialization.Certificate;
var PoolId = Cardano.PoolId;
var StakeRegistration = Serialization.StakeRegistration;
var StakeDelegation = Serialization.StakeDelegation;
var CertificateType = Cardano.CertificateType;
var VkeyWitness = Serialization.VkeyWitness;
var Ed25519SignatureHex2 = Crypto.Ed25519SignatureHex;
var Ed25519PublicKey2 = Crypto.Ed25519PublicKey;
var Ed25519Signature2 = Crypto.Ed25519Signature;
var Bip32PrivateKey2 = Crypto.Bip32PrivateKey;
var Bip32PrivateKeyHex2 = Crypto.Bip32PrivateKeyHex;
var PlutusLanguageVersion = Cardano.PlutusLanguageVersion;
var NativeScript = Serialization.NativeScript;
var PlutusV1Script = Serialization.PlutusV1Script;
var PlutusV2Script = Serialization.PlutusV2Script;
var PlutusV3Script = Serialization.PlutusV3Script;
var PlutusDataKind = Serialization.PlutusDataKind;
var PointerAddress = Cardano.PointerAddress;
var CertIndex = Cardano.CertIndex;
var TxIndex = Cardano.TxIndex;
var Costmdls = Serialization.Costmdls;
var CostModel = Serialization.CostModel;
var CborWriter = Serialization.CborWriter;
var ConstrPlutusData = Serialization.ConstrPlutusData;
var RewardAccount = Cardano.RewardAccount;
var Hash = Serialization.Hash;
var DatumHash = Crypto.Hash32ByteBase16;
var Datum = Serialization.Datum;
var ExUnits = Serialization.ExUnits;
var NetworkId = Cardano.NetworkId;
var DatumKind = Serialization.DatumKind;
var CborSet = Serialization.CborSet;
var RequireAllOf = Cardano.NativeScriptKind.RequireAllOf;
var RequireAnyOf = Cardano.NativeScriptKind.RequireAnyOf;
var RequireNOf = Cardano.NativeScriptKind.RequireNOf;
var RequireSignature = Cardano.NativeScriptKind.RequireSignature;
var RequireTimeAfter = Cardano.NativeScriptKind.RequireTimeAfter;
var RequireTimeBefore = Cardano.NativeScriptKind.RequireTimeBefore;
var VrfVkBech32 = Cardano.VrfVkBech32;
var ScriptPubkey = Serialization.ScriptPubkey;
var DRepID = Cardano.DRepID;
var DRep = Serialization.DRep;
var StakeCredentialStatus = Cardano.StakeCredentialStatus;
var computeAuxiliaryDataHash = Cardano.computeAuxiliaryDataHash;
var blake2b2 = Crypto.blake2b;

// src/stricahq/bip32ed25519/wrapper.ts
import * as cjsBip32ed25519 from "@stricahq/bip32ed25519";
var bip32ed25519 = cjsBip32ed25519;
var exportedBip32ed25519 = bip32ed25519?.default || bip32ed25519;
var StricaPrivateKey = exportedBip32ed25519.PrivateKey;
var StricaPublicKey = exportedBip32ed25519.PublicKey;
var StricaBip32PrivateKey = exportedBip32ed25519.Bip32PrivateKey;
var StricaBip32PublicKey = exportedBip32ed25519.Bip32PublicKey;

// src/stricahq/cbors/wrapper.ts
import * as cjsCbors from "@stricahq/cbors";
var cbors = cjsCbors;
var exportedCbors = cbors?.default || cbors;
var StricaEncoder = exportedCbors.Encoder;
var StricaDecoder = exportedCbors.Decoder;

// src/message-signing/cose-sign1.ts
var import_blakejs = __toESM(require_blakejs(), 1);
import { Buffer as Buffer2 } from "buffer";
var CoseSign1 = class _CoseSign1 {
  protectedMap;
  unProtectedMap;
  payload;
  signature;
  constructor(payload) {
    this.protectedMap = payload.protectedMap;
    this.unProtectedMap = payload.unProtectedMap;
    this.payload = payload.payload;
    if (this.unProtectedMap.get("hashed") == null) {
      this.unProtectedMap.set("hashed", false);
    }
    this.signature = payload.signature;
  }
  static fromCbor(cbor) {
    const decoded = StricaDecoder.decode(Buffer2.from(cbor, "hex"));
    if (!(decoded.value instanceof Array)) throw Error("Invalid CBOR");
    if (decoded.value.length !== 4) throw Error("Invalid COSE_SIGN1");
    let protectedMap;
    const protectedSerialized = decoded.value[0];
    try {
      protectedMap = StricaDecoder.decode(protectedSerialized).value;
      if (!(protectedMap instanceof Map)) {
        throw Error();
      }
    } catch (error) {
      throw Error("Invalid protected");
    }
    const unProtectedMap = decoded.value[1];
    if (!(unProtectedMap instanceof Map)) throw Error("Invalid unprotected");
    const payload = decoded.value[2];
    const signature = decoded.value[3];
    return new _CoseSign1({
      protectedMap,
      unProtectedMap,
      payload,
      signature
    });
  }
  createSigStructure(externalAad = Buffer2.alloc(0)) {
    let protectedSerialized = Buffer2.alloc(0);
    if (this.protectedMap.size !== 0) {
      protectedSerialized = StricaEncoder.encode(this.protectedMap);
    }
    const structure = [
      "Signature1",
      protectedSerialized,
      externalAad,
      this.payload
    ];
    return StricaEncoder.encode(structure);
  }
  buildMessage(signature) {
    this.signature = signature;
    let protectedSerialized = Buffer2.alloc(0);
    if (this.protectedMap.size !== 0) {
      protectedSerialized = StricaEncoder.encode(this.protectedMap);
    }
    const coseSign1 = [
      protectedSerialized,
      this.unProtectedMap,
      this.payload,
      this.signature
    ];
    return StricaEncoder.encode(coseSign1);
  }
  verifySignature({
    externalAad = Buffer2.alloc(0),
    publicKeyBuffer
  } = {}) {
    if (!publicKeyBuffer) {
      publicKeyBuffer = this.getPublicKey();
    }
    if (!publicKeyBuffer) throw Error("Public key not found");
    if (!this.signature) throw Error("Signature not found");
    const publicKey = new StricaPublicKey(publicKeyBuffer);
    return publicKey.verify(
      this.signature,
      this.createSigStructure(externalAad)
    );
  }
  hashPayload() {
    if (!this.unProtectedMap) throw Error("Invalid unprotected map");
    if (!this.payload) throw Error("Invalid payload");
    if (this.unProtectedMap.get("hashed"))
      throw Error("Payload already hashed");
    if (this.unProtectedMap.get("hashed") != false)
      throw Error("Invalid unprotected map");
    this.unProtectedMap.set("hashed", true);
    const hash = (0, import_blakejs.blake2b)(this.payload, void 0, 24);
    this.payload = Buffer2.from(hash);
  }
  getAddress() {
    return this.protectedMap.get("address");
  }
  getPublicKey() {
    return this.protectedMap.get(4);
  }
  getSignature() {
    return this.signature;
  }
  getPayload() {
    return this.payload;
  }
};
var getPublicKeyFromCoseKey = (cbor) => {
  const decodedCoseKey = StricaDecoder.decode(Buffer2.from(cbor, "hex"));
  const publicKeyBuffer = decodedCoseKey.value.get(-2);
  if (publicKeyBuffer) {
    return publicKeyBuffer;
  }
  throw Error("Public key not found");
};
var getCoseKeyFromPublicKey = (cbor) => {
  const coseKeyMap = /* @__PURE__ */ new Map();
  coseKeyMap.set(1, 1);
  coseKeyMap.set(3, -8);
  coseKeyMap.set(6, -2);
  coseKeyMap.set(-2, Buffer2.from(cbor, "hex"));
  return StricaEncoder.encode(coseKeyMap);
};

// src/message-signing/check-signature.ts
var checkSignature = (data, { key, signature }, address) => {
  const builder = CoseSign1.fromCbor(signature);
  const publicKeyBuffer = getPublicKeyFromCoseKey(key);
  if (address) {
    let network = NetworkId.Mainnet;
    const paymentAddress = BaseAddress.fromAddress(Address.fromBech32(address));
    const coseSign1PublicKey = new StricaBip32PublicKey(publicKeyBuffer);
    const credential = {
      hash: Hash28ByteBase162.fromEd25519KeyHashHex(
        Ed25519KeyHashHex2(
          coseSign1PublicKey.toPublicKey().hash().toString("hex")
        )
      ),
      type: 0
    };
    if (address.startsWith("addr")) {
      if (address.startsWith("addr_test1")) {
        network = NetworkId.Testnet;
      }
      const stakeCredential = paymentAddress?.getStakeCredential();
      if (stakeCredential) {
        const paymentAddressBech32 = BaseAddress.fromCredentials(
          network,
          credential,
          stakeCredential
        ).toAddress().toBech32();
        if (address !== paymentAddressBech32) {
          const extractedRewardAddress = RewardAddress.fromCredentials(
            network,
            stakeCredential
          ).toAddress().toBech32();
          const rewardAddress = RewardAddress.fromCredentials(
            network,
            credential
          ).toAddress().toBech32();
          if (rewardAddress !== extractedRewardAddress) {
            return false;
          }
        }
      } else {
        const enterpriseAddress = EnterpriseAddress.fromCredentials(
          network,
          credential
        ).toAddress().toBech32();
        if (enterpriseAddress !== address) {
          return false;
        }
      }
    } else if (address.startsWith("stake")) {
      if (address.startsWith("stake_test1")) {
        network = NetworkId.Testnet;
      }
      const rewardAddress = RewardAddress.fromCredentials(network, credential).toAddress().toBech32();
      if (rewardAddress !== address) {
        return false;
      }
    } else {
      return false;
    }
  }
  if (builder.getPayload() === null) {
    return false;
  }
  if (Buffer.from(data, "hex").compare(builder.getPayload()) !== 0) {
    return false;
  }
  return builder.verifySignature({
    publicKeyBuffer
  });
};

// ../../node_modules/nanoid/index.js
import crypto from "crypto";
var POOL_SIZE_MULTIPLIER = 128;
var pool;
var poolOffset;
var fillPool = (bytes) => {
  if (!pool || pool.length < bytes) {
    pool = Buffer.allocUnsafe(bytes * POOL_SIZE_MULTIPLIER);
    crypto.randomFillSync(pool);
    poolOffset = 0;
  } else if (poolOffset + bytes > pool.length) {
    crypto.randomFillSync(pool);
    poolOffset = 0;
  }
  poolOffset += bytes;
};
var random = (bytes) => {
  fillPool(bytes |= 0);
  return pool.subarray(poolOffset - bytes, poolOffset);
};
var customRandom = (alphabet, defaultSize, getRandom) => {
  let mask = (2 << 31 - Math.clz32(alphabet.length - 1 | 1)) - 1;
  let step = Math.ceil(1.6 * mask * defaultSize / alphabet.length);
  return (size = defaultSize) => {
    let id = "";
    while (true) {
      let bytes = getRandom(step);
      let i = step;
      while (i--) {
        id += alphabet[bytes[i] & mask] || "";
        if (id.length === size) return id;
      }
    }
  };
};
var customAlphabet = (alphabet, size = 21) => customRandom(alphabet, size, random);

// src/message-signing/generate-nonce.ts
import { stringToHex } from "@meshsdk/common";
var generateNonce = (label = "", length = 32) => {
  if (length <= 0 || length > 2048) {
    throw new Error("Length must be bewteen 1 and 2048");
  }
  const randomString = customAlphabet(
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
  );
  const payload = randomString(length);
  return stringToHex(`${label}${payload}`);
};

// src/message-signing/sign-data.ts
var signData = (data, signer) => {
  const payload = Buffer.from(data, "hex");
  const publicKey = signer.key.toPublicKey().toBytes();
  const protectedMap = /* @__PURE__ */ new Map();
  protectedMap.set(1, -8);
  protectedMap.set(4, publicKey);
  protectedMap.set("address", Buffer.from(signer.address.toBytes(), "hex"));
  const coseSign1Builder = new CoseSign1({
    protectedMap,
    unProtectedMap: /* @__PURE__ */ new Map(),
    payload
  });
  const signature = signer.key.sign(coseSign1Builder.createSigStructure());
  const coseSignature = coseSign1Builder.buildMessage(signature).toString("hex");
  return {
    key: getCoseKeyFromPublicKey(publicKey.toString("hex")).toString("hex"),
    signature: coseSignature
  };
};

// src/resolvers/index.ts
import { Cardano as Cardano2 } from "@cardano-sdk/core";
import { blake2b as blake2b5 } from "@cardano-sdk/crypto";
import { HexBlob as HexBlob6 } from "@cardano-sdk/util";
import base323 from "base32-encoding";
import { bech32 as bech323 } from "bech32";
import {
  fromUTF8,
  mnemonicToEntropy,
  toBytes as toBytes4
} from "@meshsdk/common";

// src/utils/builder.ts
import { blake2b as blake2b4 } from "@cardano-sdk/crypto";
import { HexBlob } from "@cardano-sdk/util";
import { pbkdf2Sync } from "pbkdf2";
import { HARDENED_KEY_START } from "@meshsdk/common";
var buildBaseAddress = (networkId, paymentKeyHash, stakeKeyHash) => {
  return BaseAddress.fromCredentials(
    networkId,
    {
      hash: paymentKeyHash,
      type: CredentialType.KeyHash
    },
    {
      hash: stakeKeyHash,
      type: CredentialType.KeyHash
    }
  );
};
var buildEnterpriseAddress = (networkId, paymentKeyHash) => {
  return EnterpriseAddress.fromCredentials(networkId, {
    hash: paymentKeyHash,
    type: CredentialType.KeyHash
  });
};
var buildBip32PrivateKey = (entropy, password = "") => {
  const PBKDF2_ITERATIONS = 4096;
  const PBKDF2_KEY_SIZE = 96;
  const PBKDF2_DIGEST_ALGORITHM = "sha512";
  const clampScalar = (scalar) => {
    if (scalar[0] !== void 0) {
      scalar[0] &= 248;
    }
    if (scalar[31] !== void 0) {
      scalar[31] &= 31;
      scalar[31] |= 64;
    }
    return scalar;
  };
  const _entropy = Buffer.from(entropy, "hex");
  const xprv = pbkdf2Sync(
    password,
    _entropy,
    PBKDF2_ITERATIONS,
    PBKDF2_KEY_SIZE,
    PBKDF2_DIGEST_ALGORITHM
  );
  return Bip32PrivateKey2.fromBytes(clampScalar(xprv));
};
var buildRewardAddress = (networkId, stakeKeyHash) => {
  const cred = {
    type: CredentialType.KeyHash,
    hash: stakeKeyHash
  };
  return RewardAddress.fromCredentials(networkId, cred);
};
var buildKeys = (entropy, accountIndex, keyIndex = 0) => {
  if (typeof entropy === "string") {
    const rootKey = new StricaBip32PrivateKey(Buffer.from(entropy, "hex"));
    const accountKey = rootKey.derive(HARDENED_KEY_START + 1852).derive(HARDENED_KEY_START + 1815).derive(HARDENED_KEY_START + accountIndex);
    const paymentKey = accountKey.derive(0).derive(keyIndex).toPrivateKey();
    const stakeKey = accountKey.derive(2).derive(0).toPrivateKey();
    const dRepKey = accountKey.derive(3).derive(keyIndex).toPrivateKey();
    return { paymentKey, stakeKey, dRepKey };
  } else {
    const paymentKey = StricaPrivateKey.fromSecretKey(
      Buffer.from(entropy[0], "hex")
    );
    const stakeKey = StricaPrivateKey.fromSecretKey(
      Buffer.from(entropy[1], "hex")
    );
    return { paymentKey, stakeKey };
  }
};
var buildScriptPubkey = (keyHash) => {
  const scriptPubkey = new ScriptPubkey(Ed25519KeyHashHex2(keyHash.hex()));
  return NativeScript.newScriptPubkey(scriptPubkey);
};
var buildDRepID = (dRepKey, networkId = NetworkId.Testnet, addressType = AddressType.EnterpriseKey) => {
  const dRepKeyBytes = Buffer.from(dRepKey, "hex");
  const dRepIdHex = blake2b4(28).update(dRepKeyBytes).digest("hex");
  const paymentAddress = EnterpriseAddress.packParts({
    networkId,
    paymentPart: {
      hash: Hash28ByteBase162(dRepIdHex),
      type: CredentialType.KeyHash
    },
    type: addressType
  });
  return HexBlob.toTypedBech32(
    "drep",
    HexBlob.fromBytes(paymentAddress)
  );
};

// src/utils/converter.ts
import { Serialization as Serialization3 } from "@cardano-sdk/core";
import { Ed25519KeyHash as Ed25519KeyHash4 } from "@cardano-sdk/crypto";
import { HexBlob as HexBlob4 } from "@cardano-sdk/util";
import base32 from "base32-encoding";
import { bech32 } from "bech32";
import {
  toBytes as toBytes3
} from "@meshsdk/common";

// src/utils/data.ts
import { HexBlob as HexBlob2 } from "@cardano-sdk/util";
import { toBytes } from "@meshsdk/common";
var toPlutusData = (data) => {
  const toPlutusList = (data2) => {
    const plutusList = new PlutusList();
    data2.forEach((element) => {
      plutusList.add(toPlutusData(element));
    });
    return plutusList;
  };
  switch (typeof data) {
    case "string":
      return PlutusData.newBytes(toBytes(data));
    case "number":
      return PlutusData.newInteger(BigInt(data));
    case "bigint":
      return PlutusData.newInteger(BigInt(data));
    case "object":
      if (data instanceof Array) {
        const plutusList = toPlutusList(data);
        return PlutusData.newList(plutusList);
      } else if (data instanceof Map) {
        const plutusMap = new PlutusMap();
        data.forEach((value, key) => {
          plutusMap.insert(toPlutusData(key), toPlutusData(value));
        });
        return PlutusData.newMap(plutusMap);
      } else {
        return PlutusData.newConstrPlutusData(
          new ConstrPlutusData(
            BigInt(data.alternative),
            toPlutusList(data.fields)
          )
        );
      }
  }
};
var isConstrPlutusDataJson = (data) => {
  return typeof data === "object" && "constructor" in data && (typeof data.constructor === "number" || typeof data.constructor === "bigint" || typeof data.constructor === "string") && "fields" in data && Array.isArray(data.fields);
};
function isMapPlutusDataJson(data) {
  return typeof data === "object" && Array.isArray(data);
}
function isKeyValuePlutusDataJson(data) {
  return typeof data === "object" && "k" in data && typeof data.k === "object" && "v" in data && typeof data.v === "object";
}
var fromJsonToPlutusData = (data) => {
  if (isConstrPlutusDataJson(data)) {
    const plutusList = new PlutusList();
    data.fields.map((val) => {
      plutusList.add(fromJsonToPlutusData(val));
    });
    const plutusConstrData = new ConstrPlutusData(
      BigInt(data.constructor),
      plutusList
    );
    return PlutusData.newConstrPlutusData(plutusConstrData);
  } else if ("int" in data && Object.keys(data).length === 1) {
    if (typeof data.int === "bigint" || typeof data.int === "number" || typeof data.int === "string") {
      return PlutusData.newInteger(BigInt(data.int));
    } else {
      throw new Error(
        "Malformed int field in Plutus data, expected one of bigint, number or string"
      );
    }
  } else if ("bytes" in data && Object.keys(data).length === 1) {
    if (typeof data.bytes === "string") {
      return PlutusData.newBytes(Buffer.from(data.bytes, "hex"));
    } else {
      throw new Error("Malformed bytes field in Plutus data, expected string");
    }
  } else if ("list" in data && Object.keys(data).length === 1) {
    if (Array.isArray(data.list)) {
      const plutusList = new PlutusList();
      data.list.map((val) => {
        plutusList.add(fromJsonToPlutusData(val));
      });
      return PlutusData.newList(plutusList);
    } else {
      throw new Error("Malformed list field in Plutus data, expected list");
    }
  } else if ("map" in data && Object.keys(data).length === 1) {
    if (isMapPlutusDataJson(data.map)) {
      const plutusMap = new PlutusMap();
      data.map.forEach((val) => {
        if (isKeyValuePlutusDataJson(val)) {
          plutusMap.insert(
            fromJsonToPlutusData(val.k),
            fromJsonToPlutusData(val.v)
          );
        } else {
          throw new Error("Malformed key value pair in Plutus data map");
        }
      });
      return PlutusData.newMap(plutusMap);
    } else {
      console.log(data);
      throw new Error("Malformed map field in Plutus data");
    }
  } else {
    throw new Error("Malformed Plutus data json");
  }
};
var fromBuilderToPlutusData = (data) => {
  if (data.type === "Mesh") {
    return toPlutusData(data.content);
  } else if (data.type === "CBOR") {
    return PlutusData.fromCbor(HexBlob2(data.content));
  } else if (data.type === "JSON") {
    let content;
    if (typeof data.content === "string") {
      content = JSON.parse(data.content);
    } else {
      content = data.content;
    }
    return fromJsonToPlutusData(content);
  } else {
    throw new Error(
      "Malformed builder data, expected types of, Mesh, CBOR or JSON"
    );
  }
};
var fromPlutusDataToJson = (data) => {
  if (data.getKind() === PlutusDataKind.ConstrPlutusData) {
    const plutusData = data.asConstrPlutusData();
    if (plutusData) {
      const fields = plutusData.getData();
      return {
        constructor: plutusData.getAlternative(),
        fields: fromPlutusDataToJson(PlutusData.newList(fields))
      };
    } else {
      throw new Error("Invalid constructor data found");
    }
  } else if (data.getKind() === PlutusDataKind.Map) {
    const plutusMap = data.asMap();
    const mapList = [];
    if (plutusMap) {
      const keys = plutusMap.getKeys();
      for (let i = 0; i < keys.getLength(); i++) {
        const key = keys.get(i);
        const value = plutusMap.get(key);
        if (value) {
          mapList.push({
            k: fromPlutusDataToJson(key),
            v: fromPlutusDataToJson(value)
          });
        }
      }
      return {
        map: mapList
      };
    } else {
      throw new Error("Invalid map data found");
    }
  } else if (data.getKind() === PlutusDataKind.List) {
    const plutusList = data.asList();
    if (plutusList) {
      const list = [];
      for (let i = 0; i < plutusList.getLength(); i++) {
        const element = plutusList.get(i);
        list.push(fromPlutusDataToJson(element));
      }
      return list;
    } else {
      throw new Error("Invalid list data found");
    }
  } else if (data.getKind() === PlutusDataKind.Integer) {
    const plutusInt = data.asInteger();
    if (plutusInt) {
      return {
        int: BigInt(plutusInt.toString())
      };
    } else {
      throw new Error("Invalid integer data found");
    }
  } else if (data.getKind() === PlutusDataKind.Bytes) {
    const plutusBytes = data.asBoundedBytes();
    if (plutusBytes) {
      return {
        bytes: Buffer.from(plutusBytes).toString("hex")
      };
    } else {
      throw new Error("Invalid bytes data found");
    }
  } else {
    throw new Error("Invalid Plutus data found");
  }
};
var datumCborToJson = (datumCbor) => {
  const parsedDatum = PlutusData.fromCbor(HexBlob2(datumCbor));
  return fromPlutusDataToJson(parsedDatum);
};
var parseDatumCbor = (datumCbor) => {
  return datumCborToJson(datumCbor);
};
var parseInlineDatum = (utxo) => {
  const datumCbor = utxo.inline_datum || "";
  return datumCborToJson(datumCbor);
};
var deserializeDataHash = (dataHash) => DatumHash.fromHexBlob(HexBlob2(dataHash));
var deserializePlutusData = (plutusData) => PlutusData.fromCbor(HexBlob2(plutusData));

// src/utils/deserializer.ts
import { Serialization as Serialization2 } from "@cardano-sdk/core";
import { Ed25519KeyHashHex as Ed25519KeyHashHex3 } from "@cardano-sdk/crypto";
import { HexBlob as HexBlob3 } from "@cardano-sdk/util";
import { toBytes as toBytes2 } from "@meshsdk/common";
var deserializeEd25519KeyHash = (ed25519KeyHash) => Ed25519KeyHash2.fromBytes(toBytes2(ed25519KeyHash));
var deserializePlutusScript = (plutusScript, version) => {
  switch (version) {
    case "V1":
      return PlutusV1Script.fromCbor(HexBlob3(plutusScript));
    case "V2":
      return PlutusV2Script.fromCbor(HexBlob3(plutusScript));
    case "V3":
      return PlutusV3Script.fromCbor(HexBlob3(plutusScript));
    default:
      throw new Error("Invalid Plutus script version");
  }
};
var deserializeNativeScript = (nativeScript) => NativeScript.fromCbor(HexBlob3(nativeScript));
var deserializeScriptHash = (scriptHash) => ScriptHash.fromEd25519KeyHashHex(Ed25519KeyHashHex3(scriptHash));
var deserializeScriptRef = (scriptRef) => Script.fromCbor(HexBlob3(scriptRef));
var deserializeTxUnspentOutput = (txUnspentOutput) => TransactionUnspentOutput.fromCbor(HexBlob3(txUnspentOutput));
var deserializeValue = (value) => Value.fromCbor(HexBlob3(value));
var deserializeTx = (tx) => Transaction.fromCbor(Serialization2.TxCBOR(tx));
var deserializeTxHash = (txHash) => TransactionId.fromHexBlob(HexBlob3(txHash));

// src/utils/converter.ts
var toAddress = (bech325) => Address.fromBech32(bech325);
var toCardanoAddress = (address) => {
  try {
    return Address.fromBech32(address);
  } catch {
    try {
      return Address.fromBase58(address);
    } catch {
      throw new Error("Invalid address format");
    }
  }
};
var toBaseAddress = (bech325) => {
  return BaseAddress.fromAddress(toAddress(bech325));
};
var toEnterpriseAddress = (bech325) => {
  return EnterpriseAddress.fromAddress(toAddress(bech325));
};
var toRewardAddress = (bech325) => RewardAddress.fromAddress(toAddress(bech325));
var fromTxUnspentOutput = (txUnspentOutput) => {
  const dataHash = txUnspentOutput.output().datum() ? txUnspentOutput.output().datum()?.toCbor().toString() : void 0;
  const scriptRef = txUnspentOutput.output().scriptRef() ? txUnspentOutput.output().scriptRef()?.toCbor().toString() : void 0;
  const plutusData = txUnspentOutput.output().datum()?.asInlineData() ? txUnspentOutput.output().datum()?.asInlineData()?.toCbor().toString() : void 0;
  return {
    input: {
      outputIndex: Number(txUnspentOutput.input().index()),
      txHash: txUnspentOutput.input().transactionId()
    },
    output: {
      address: txUnspentOutput.output().address().toBech32(),
      amount: fromValue(txUnspentOutput.output().amount()),
      dataHash,
      // todo not sure if correct
      plutusData,
      // todo not sure if correct
      scriptRef
      // todo not sure if correct
    }
  };
};
var toTxUnspentOutput = (utxo) => {
  const txInput = new TransactionInput(
    deserializeTxHash(utxo.input.txHash),
    BigInt(utxo.input.outputIndex)
  );
  const txOutput = new TransactionOutput(
    toAddress(utxo.output.address),
    toValue(utxo.output.amount)
  );
  if (utxo.output.dataHash !== void 0) {
    txOutput.setDatum(
      Datum.fromCore(deserializeDataHash(utxo.output.dataHash))
    );
  }
  if (utxo.output.plutusData !== void 0) {
    const plutusData = deserializePlutusData(utxo.output.plutusData);
    const datum = new Serialization3.Datum(void 0, plutusData);
    txOutput.setDatum(datum);
  }
  if (utxo.output.scriptRef !== void 0) {
    txOutput.setScriptRef(deserializeScriptRef(utxo.output.scriptRef));
  }
  return new TransactionUnspentOutput(txInput, txOutput);
};
var addressToBech32 = (address) => {
  return address.toBech32();
};
var fromValue = (value) => {
  const assets = [
    { unit: "lovelace", quantity: value.coin().toString() }
  ];
  const multiAsset = value.multiasset();
  if (multiAsset !== void 0) {
    const _assets = Array.from(multiAsset.keys());
    for (let i = 0; i < _assets.length; i += 1) {
      const assetId = _assets[i];
      if (assetId !== void 0) {
        const assetQuantity = multiAsset.get(assetId);
        if (assetQuantity !== void 0) {
          assets.push({
            unit: assetId,
            quantity: assetQuantity.toString()
          });
        }
      }
    }
  }
  return assets;
};
var toScriptRef = (script) => {
  if ("code" in script) {
    const plutusScript = deserializePlutusScript(script.code, script.version);
    if (plutusScript instanceof PlutusV1Script)
      return Script.newPlutusV1Script(plutusScript);
    if (plutusScript instanceof PlutusV2Script)
      return Script.newPlutusV2Script(plutusScript);
    if (plutusScript instanceof PlutusV3Script)
      return Script.newPlutusV3Script(plutusScript);
  }
  return Script.newNativeScript(toNativeScript(script));
};
var fromScriptRef = (scriptRef) => {
  const script = Script.fromCbor(HexBlob4(scriptRef));
  const plutusScriptCodeV3 = script.asPlutusV3()?.toCbor().toString();
  if (plutusScriptCodeV3) {
    return {
      code: plutusScriptCodeV3,
      version: "V3"
    };
  }
  const plutusScriptCodeV2 = script.asPlutusV2()?.toCbor().toString();
  if (plutusScriptCodeV2) {
    return {
      code: plutusScriptCodeV2,
      version: "V2"
    };
  }
  const plutusScriptCodeV1 = script.asPlutusV1()?.toCbor().toString();
  if (plutusScriptCodeV1) {
    return {
      code: plutusScriptCodeV1,
      version: "V1"
    };
  }
  const nativeScript = script.asNative();
  if (!nativeScript) {
    throw new Error("Invalid script");
  }
  return fromNativeScript(nativeScript);
};
var fromNativeScript = (script) => {
  const fromNativeScripts = (scripts) => {
    const nativeScripts = new Array();
    for (let index = 0; index < scripts.length; index += 1) {
      const script2 = scripts[index];
      if (script2) {
        nativeScripts.push(fromNativeScript(script2));
      }
    }
    return nativeScripts;
  };
  switch (script.kind()) {
    case RequireAllOf: {
      const scriptAll = script.asScriptAll();
      return {
        type: "all",
        scripts: fromNativeScripts(scriptAll.nativeScripts())
      };
    }
    case RequireAnyOf: {
      const scriptAny = script.asScriptAny();
      return {
        type: "any",
        scripts: fromNativeScripts(scriptAny.nativeScripts())
      };
    }
    case RequireNOf: {
      const scriptNOfK = script.asScriptNOfK();
      return {
        type: "atLeast",
        required: scriptNOfK.required(),
        scripts: fromNativeScripts(scriptNOfK.nativeScripts())
      };
    }
    case RequireTimeAfter: {
      const timelockStart = script.asTimelockStart();
      return {
        type: "after",
        slot: timelockStart.slot().toString()
      };
    }
    case RequireTimeBefore: {
      const timelockExpiry = script.asTimelockExpiry();
      return {
        type: "before",
        slot: timelockExpiry.slot().toString()
      };
    }
    case RequireSignature: {
      const scriptPubkey = script.asScriptPubkey();
      return {
        type: "sig",
        keyHash: scriptPubkey.keyHash().toString()
      };
    }
    default:
      throw new Error(`Script Kind: ${script.kind()}, is not supported`);
  }
};
var toNativeScript = (script) => {
  const toNativeScripts = (scripts) => {
    const nativeScripts = [];
    scripts.forEach((script2) => {
      nativeScripts.push(toNativeScript(script2));
    });
    return nativeScripts;
  };
  switch (script.type) {
    case "all":
      return NativeScript.newScriptAll(
        new Serialization3.ScriptAll(toNativeScripts(script.scripts))
      );
    case "any":
      return NativeScript.newScriptAny(
        new Serialization3.ScriptAny(toNativeScripts(script.scripts))
      );
    case "atLeast":
      return NativeScript.newScriptNOfK(
        new Serialization3.ScriptNOfK(
          toNativeScripts(script.scripts),
          script.required
        )
      );
    case "after":
      return NativeScript.newTimelockStart(
        new Serialization3.TimelockStart(Slot(parseInt(script.slot)))
      );
    case "before":
      return NativeScript.newTimelockExpiry(
        new Serialization3.TimelockExpiry(Slot(parseInt(script.slot)))
      );
    case "sig":
      return NativeScript.newScriptPubkey(
        new Serialization3.ScriptPubkey(
          Ed25519KeyHash4.fromBytes(toBytes3(script.keyHash)).hex()
        )
      );
  }
};
var toValue = (assets) => {
  const multiAsset = /* @__PURE__ */ new Map();
  assets.filter((asset) => asset.unit !== "lovelace").forEach((asset) => {
    multiAsset.set(AssetId(asset.unit), BigInt(asset.quantity));
  });
  const lovelace = assets.find((asset) => asset.unit === "lovelace");
  const value = new Value(BigInt(lovelace ? lovelace.quantity : 0));
  if (assets.length > 1 || !lovelace) {
    value.setMultiasset(multiAsset);
  }
  return value;
};
var toDRep = (dRepId) => {
  if (dRepId.length === 58) {
    const { prefix, words } = bech32.decode(dRepId);
    if (prefix !== "drep") {
      throw new Error("Invalid DRepId prefix");
    }
    const bytes = base32.decode(new Uint8Array(words));
    if (bytes[0] === 34) {
      return Serialization3.DRep.newKeyHash(
        Ed25519KeyHashHex2(bytes.subarray(1).toString("hex"))
      );
    } else if (bytes[0] === 35) {
      return Serialization3.DRep.newScriptHash(
        Hash28ByteBase162(bytes.subarray(1).toString("hex"))
      );
    } else {
      throw new Error("Malformed CIP129 DRepId");
    }
  } else {
    const { prefix, words } = bech32.decode(dRepId);
    switch (prefix) {
      case "drep": {
        return Serialization3.DRep.newKeyHash(
          Ed25519KeyHashHex2(
            base32.decode(new Uint8Array(words)).toString("hex")
          )
        );
      }
      case "drep_script": {
        return Serialization3.DRep.newScriptHash(
          Hash28ByteBase162(
            base32.decode(new Uint8Array(words)).toString("hex")
          )
        );
      }
      default: {
        throw new Error("Malformed DRepId prefix");
      }
    }
  }
};
var getDRepIds = (dRepId) => {
  let result = {
    cip105: "",
    cip129: ""
  };
  if (dRepId.length === 58) {
    result.cip129 = dRepId;
    const { prefix, words } = bech32.decode(dRepId);
    if (prefix !== "drep") {
      throw new Error("Malformed CIP129 DRepId");
    }
    const bytes = base32.decode(new Uint8Array(words));
    if (bytes[0] === 34) {
      result.cip105 = bech32.encode("drep", base32.encode(bytes.subarray(1)));
    } else if (bytes[0] === 35) {
      result.cip105 = bech32.encode(
        "drep_script",
        base32.encode(bytes.subarray(1))
      );
    } else {
      throw new Error("Malformed CIP129 DRepId");
    }
  } else {
    result.cip105 = dRepId;
    try {
      const { prefix, words } = bech32.decode(dRepId);
      let rawBytes = base32.decode(new Uint8Array(words));
      if (prefix === "drep") {
        if (!rawBytes) {
          throw new Error("Malformed key hash in DRepId");
        }
        let rawBytesWithPrefix = new Uint8Array(rawBytes.length + 1);
        rawBytesWithPrefix.set([34]);
        rawBytesWithPrefix.set(rawBytes, 1);
        let base32RawBytes = base32.encode(rawBytesWithPrefix);
        result.cip129 = bech32.encode("drep", base32RawBytes);
      } else if (prefix === "drep_script") {
        if (!rawBytes) {
          throw new Error("Malformed script hash in DRepId");
        }
        let rawBytesWithPrefix = new Uint8Array(rawBytes.length + 1);
        rawBytesWithPrefix.set([35]);
        rawBytesWithPrefix.set(rawBytes, 1);
        let base32RawBytes = base32.encode(rawBytesWithPrefix);
        result.cip129 = bech32.encode("drep", base32RawBytes);
      } else {
        throw new Error("Can only calculate DRepIds for script/key DReps");
      }
    } catch (e) {
      console.error(e);
      throw new Error("Malformed DRepId");
    }
  }
  return result;
};

// src/utils/value.ts
function mergeValue(a, b) {
  const ma = a.multiasset() ?? /* @__PURE__ */ new Map();
  b.multiasset()?.forEach((v, k) => {
    const newVal = (ma.get(k) ?? 0n) + v;
    if (newVal == 0n) {
      ma.delete(k);
    } else {
      ma.set(k, newVal);
    }
  });
  return new Value(
    BigInt(a.coin()) + BigInt(b.coin()),
    ma.size > 0 ? ma : void 0
  );
}
function negateValue(v) {
  const entries = v.multiasset()?.entries();
  const tokenMap = /* @__PURE__ */ new Map();
  if (entries) {
    for (const entry of entries) {
      tokenMap.set(entry[0], -entry[1]);
    }
  }
  return new Value(-v.coin(), tokenMap);
}
function subValue(a, b) {
  return mergeValue(a, negateValue(b));
}
function negatives(v) {
  const entries = v.multiasset()?.entries();
  const coin = v.coin() < 0n ? v.coin() : 0n;
  const tokenMap = /* @__PURE__ */ new Map();
  if (entries) {
    for (const entry of entries) {
      if (entry[1] < 0n) {
        tokenMap.set(entry[0], entry[1]);
      }
    }
  }
  return new Value(coin, tokenMap);
}
function assetTypes(v) {
  let count = v.coin() == 0n ? 0 : 1;
  const entries = v.multiasset();
  if (entries) {
    entries.forEach(() => {
      count += 1;
    });
  }
  return count;
}
function empty(v) {
  return assetTypes(v) == 0;
}

// src/utils/address.ts
import { HexBlob as HexBlob5 } from "@cardano-sdk/util";
import {
  pubKeyAddress,
  scriptAddress
} from "@meshsdk/common";
var serialzeAddress = (deserializedAddress, networkId = 0) => {
  const {
    pubKeyHash,
    scriptHash,
    stakeCredentialHash,
    stakeScriptCredentialHash
  } = deserializedAddress;
  const isPaymentScript = !pubKeyHash;
  const isStakeScript = !stakeCredentialHash;
  const paymentHash = isPaymentScript ? scriptHash : pubKeyHash;
  const stakeHash = isStakeScript ? stakeScriptCredentialHash : stakeCredentialHash;
  if (!paymentHash)
    throw new Error(
      "Error: serializeAddress: Address must contain a payment part"
    );
  const addressObj = isPaymentScript ? scriptAddress(paymentHash, stakeHash, isStakeScript) : pubKeyAddress(paymentHash, stakeHash, isStakeScript);
  return serializeAddressObj(addressObj, networkId);
};
var addrBech32ToPlutusData = (bech325) => {
  const cardanoAddress = Address.fromBech32(bech325);
  const cardanoAddressProps = cardanoAddress.getProps();
  const paymentPartList = new PlutusList();
  if (!cardanoAddressProps.paymentPart) {
    throw new Error(
      "Error: addrBech32ToPlutusDataHex: Address must contain a payment part"
    );
  }
  paymentPartList.add(
    PlutusData.newBytes(
      Buffer.from(cardanoAddressProps.paymentPart.hash, "hex")
    )
  );
  const paymentPart = PlutusData.newConstrPlutusData(
    new ConstrPlutusData(
      BigInt(cardanoAddressProps.paymentPart.type),
      paymentPartList
    )
  );
  const delegationPartList = new PlutusList();
  let delegationPart;
  if (cardanoAddressProps.delegationPart) {
    delegationPartList.add(
      PlutusData.newBytes(
        Buffer.from(cardanoAddressProps.delegationPart.hash, "hex")
      )
    );
    const inlineDelegationPart = PlutusData.newConstrPlutusData(
      new ConstrPlutusData(BigInt(0), delegationPartList)
    );
    const someList = new PlutusList();
    someList.add(inlineDelegationPart);
    delegationPart = PlutusData.newConstrPlutusData(
      new ConstrPlutusData(BigInt(0), someList)
    );
  } else if (cardanoAddressProps.pointer) {
    const pointerList = new PlutusList();
    pointerList.add(
      PlutusData.newInteger(BigInt(cardanoAddressProps.pointer.slot))
    );
    pointerList.add(
      PlutusData.newInteger(BigInt(cardanoAddressProps.pointer.txIndex))
    );
    pointerList.add(
      PlutusData.newInteger(BigInt(cardanoAddressProps.pointer.certIndex))
    );
    const pointer = PlutusData.newConstrPlutusData(
      new ConstrPlutusData(BigInt(1), pointerList)
    );
    const someList = new PlutusList();
    someList.add(pointer);
    delegationPart = PlutusData.newConstrPlutusData(
      new ConstrPlutusData(BigInt(0), someList)
    );
  } else {
    delegationPart = PlutusData.newConstrPlutusData(
      new ConstrPlutusData(BigInt(1), new PlutusList())
    );
  }
  const addressList = new PlutusList();
  addressList.add(paymentPart);
  addressList.add(delegationPart);
  return PlutusData.newConstrPlutusData(
    new ConstrPlutusData(BigInt(0), addressList)
  );
};
var addrBech32ToPlutusDataHex = (bech325) => {
  return addrBech32ToPlutusData(bech325).toCbor();
};
var addrBech32ToPlutusDataObj = (bech325) => {
  return fromPlutusDataToJson(addrBech32ToPlutusData(bech325));
};
var plutusDataToAddrBech32 = (plutusData, networkId = 0) => {
  const constrPlutusData = plutusData.asConstrPlutusData();
  if (!constrPlutusData || constrPlutusData.getAlternative() !== BigInt(0)) {
    throw new Error(
      "Error: serializeAddressObj: Address must contain a constructor 0"
    );
  }
  const plutusDataList = constrPlutusData.getData();
  if (plutusDataList.getLength() !== 2) {
    throw new Error("Error: serializeAddressObj: Address must contain 2 parts");
  }
  const paymentData = plutusDataList.get(0);
  const paymentConstrData = paymentData.asConstrPlutusData();
  if (!paymentConstrData) {
    throw new Error(
      "Error: serializeAddressObj: Payment part must be a constructor"
    );
  }
  const paymentConstrDataList = paymentConstrData.getData();
  if (paymentConstrDataList.getLength() !== 1) {
    throw new Error(
      "Error: serializeAddressObj: Payment part must contain 1 element"
    );
  }
  const paymentBytes = paymentConstrDataList.get(0).asBoundedBytes();
  if (!paymentBytes) {
    throw new Error(
      "Error: serializeAddressObj: Payment inner part must be bytes"
    );
  }
  if (paymentConstrData.getAlternative() !== BigInt(0) && paymentConstrData.getAlternative() !== BigInt(1)) {
    throw new Error(
      "Error: serializeAddressObj: Payment part must be alternative 0 or 1"
    );
  }
  const cardanoPaymentCredential = {
    hash: Hash28ByteBase162(Buffer.from(paymentBytes).toString("hex")),
    type: paymentConstrData.getAlternative() === BigInt(0) ? 0 : 1
  };
  const delegationData = plutusDataList.get(1);
  const delegationConstrData = delegationData.asConstrPlutusData();
  if (!delegationConstrData) {
    throw new Error(
      "Error: serializeAddressObj: Delegation part must be a constructor"
    );
  }
  if (delegationConstrData.getAlternative() === BigInt(1)) {
    return EnterpriseAddress.fromCredentials(
      networkId,
      cardanoPaymentCredential
    ).toAddress().toBech32();
  } else if (delegationConstrData.getAlternative() === BigInt(0)) {
    const delegationDataList = delegationConstrData.getData();
    if (delegationDataList.getLength() !== 1) {
      throw new Error(
        "Error: serializeAddressObj: Delegation part must contain 1 element"
      );
    }
    const delegationDataInner = delegationDataList.get(0);
    const delegationDataInnerConstrData = delegationDataInner.asConstrPlutusData();
    if (!delegationDataInnerConstrData) {
      throw new Error(
        "Error: serializeAddressObj: Delegation inner part must be a constructor"
      );
    }
    if (delegationDataInnerConstrData.getAlternative() === BigInt(0)) {
      const delegationDataInnerList = delegationDataInnerConstrData.getData();
      if (delegationDataInnerList.getLength() !== 1) {
        throw new Error(
          "Error: serializeAddressObj: Delegation inner part must contain 1 element"
        );
      }
      const delegationBytes = delegationDataInnerList.get(0).asBoundedBytes();
      if (!delegationBytes) {
        throw new Error(
          "Error: serializeAddressObj: Delegation inner part must be bytes"
        );
      }
      const cardanoStakeCredential = {
        hash: Hash28ByteBase162(Buffer.from(delegationBytes).toString("hex")),
        type: delegationDataInnerConstrData.getAlternative() === BigInt(0) ? 0 : 1
      };
      return BaseAddress.fromCredentials(
        networkId,
        cardanoPaymentCredential,
        cardanoStakeCredential
      ).toAddress().toBech32();
    } else if (delegationDataInnerConstrData.getAlternative() === BigInt(1)) {
      const delegationDataInnerList = delegationDataInnerConstrData.getData();
      if (delegationDataInnerList.getLength() !== 3) {
        throw new Error(
          "Error: serializeAddressObj: Delegation inner part must contain 3 elements"
        );
      }
      const slot = delegationDataInnerList.get(0).asInteger();
      if (!slot) {
        throw new Error(
          "Error: serializeAddressObj: Delegation inner part slot must be integer"
        );
      }
      const txIndex = delegationDataInnerList.get(1).asInteger();
      if (!txIndex) {
        throw new Error(
          "Error: serializeAddressObj: Delegation inner part txIndex must be integer"
        );
      }
      const certIndex = delegationDataInnerList.get(2).asInteger();
      if (!certIndex) {
        throw new Error(
          "Error: serializeAddressObj: Delegation inner part certIndex must be integer"
        );
      }
      const cardanoPointer = {
        slot,
        txIndex: TxIndex(Number(txIndex)),
        certIndex: CertIndex(Number(certIndex))
      };
      return PointerAddress.fromCredentials(
        networkId,
        cardanoPaymentCredential,
        cardanoPointer
      ).toAddress().toBech32();
    } else {
      throw new Error(
        "Error: serializeAddressObj: Delegation inner part must be alternative 0 or 1"
      );
    }
  } else {
    throw new Error(
      "Error: serializeAddressObj: Delegation part must be alternative 0 or 1"
    );
  }
};
var serializeAddressObj = (plutusDataAddressObject, networkId = 0) => {
  const cardanoPlutusData = fromJsonToPlutusData(plutusDataAddressObject);
  return plutusDataToAddrBech32(cardanoPlutusData, networkId);
};
var serializePlutusAddressToBech32 = (plutusHex, networkId = 0) => {
  const cardanoPlutusData = PlutusData.fromCbor(HexBlob5(plutusHex));
  return plutusDataToAddrBech32(cardanoPlutusData, networkId);
};
var deserializeBech32Address = (bech32Addr) => {
  const deserializedAddress = Address.fromBech32(bech32Addr).getProps();
  return {
    pubKeyHash: deserializedAddress.paymentPart?.type === CredentialType.KeyHash ? deserializedAddress.paymentPart?.hash : "",
    scriptHash: deserializedAddress.paymentPart?.type === CredentialType.ScriptHash ? deserializedAddress.paymentPart?.hash : "",
    stakeCredentialHash: deserializedAddress.delegationPart?.type === CredentialType.KeyHash ? deserializedAddress.delegationPart?.hash : "",
    stakeScriptCredentialHash: deserializedAddress.delegationPart?.type === CredentialType.ScriptHash ? deserializedAddress.delegationPart?.hash : ""
  };
};
var deserializeAddress = (address) => {
  const _address = Address.fromString(address);
  if (_address === null) throw new Error("Invalid address");
  return _address;
};
var scriptHashToBech32 = (scriptHash, stakeCredentialHash, networkId = 0, isScriptStakeCredentialHash = false) => {
  if (stakeCredentialHash) {
    return BaseAddress.fromCredentials(
      networkId,
      { hash: Hash28ByteBase162(scriptHash), type: CredentialType.ScriptHash },
      {
        hash: Hash28ByteBase162(stakeCredentialHash),
        type: isScriptStakeCredentialHash ? CredentialType.ScriptHash : CredentialType.KeyHash
      }
    ).toAddress().toBech32().toString();
  } else {
    return EnterpriseAddress.fromCredentials(networkId, {
      hash: Hash28ByteBase162(scriptHash),
      type: CredentialType.ScriptHash
    }).toAddress().toBech32().toString();
  }
};
var v2ScriptToBech32 = (scriptCbor, stakeCredential, networkId = 0, isScriptStakeCredential = false) => scriptHashToBech32(
  Script.fromCbor(HexBlob5(scriptCbor)).hash().toString(),
  stakeCredential,
  networkId,
  isScriptStakeCredential
);
var scriptHashToRewardAddress = (hash, networkId = 0) => {
  return RewardAddress.fromCredentials(networkId, {
    hash: Hash28ByteBase162(hash),
    type: CredentialType.ScriptHash
  }).toAddress().toBech32().toString();
};
var keyHashToRewardAddress = (hash, networkId = 0) => {
  return RewardAddress.fromCredentials(networkId, {
    hash: Hash28ByteBase162(hash),
    type: CredentialType.KeyHash
  }).toAddress().toBech32().toString();
};

// src/utils/encoding.ts
import base322 from "base32-encoding";
import { bech32 as bech322 } from "bech32";
var bytesToHex = (bytes) => Buffer.from(bytes).toString("hex");
var hexToBytes = (hex) => Buffer.from(hex, "hex");
var utf8ToBytes = (str) => Buffer.from(str, "utf8");
var utf8ToHex = (str) => Buffer.from(str, "utf8").toString("hex");
var hexToBech32 = (prefix, hex) => {
  const buf = Buffer.from(hex, "hex");
  const base32RawBytes = base322.encode(buf);
  return bech322.encode(prefix, base32RawBytes);
};

// src/resolvers/index.ts
var resolveDataHash = (data) => {
  const plutusData = toPlutusData(data);
  return plutusData.hash().toString();
};
var resolveNativeScriptAddress = (script, networkId = 0) => {
  const nativeScript = toNativeScript(script);
  const enterpriseAddress = EnterpriseAddress.fromCredentials(networkId, {
    hash: nativeScript.hash(),
    type: Cardano2.CredentialType.ScriptHash
  });
  return enterpriseAddress.toAddress().toBech32().toString();
};
var resolveNativeScriptHash = (script) => {
  return toNativeScript(script).hash().toString();
};
var resolvePaymentKeyHash = (bech325) => {
  try {
    const paymentKeyHash = [
      toBaseAddress(bech325)?.getPaymentCredential().hash,
      toEnterpriseAddress(bech325)?.getPaymentCredential().hash
    ].find((kh) => kh !== void 0);
    if (paymentKeyHash !== void 0) return paymentKeyHash.toString();
    throw new Error(
      `Couldn't resolve payment key hash from address: ${bech325}`
    );
  } catch (error) {
    throw new Error(
      `An error occurred during resolvePaymentKeyHash: ${error}.`
    );
  }
};
var resolvePlutusScriptAddress = (script, networkId = 0) => {
  const plutusScript = deserializePlutusScript(script.code, script.version);
  const enterpriseAddress = EnterpriseAddress.fromCredentials(networkId, {
    hash: plutusScript.hash(),
    type: Cardano2.CredentialType.ScriptHash
  });
  return enterpriseAddress.toAddress().toBech32().toString();
};
var resolvePlutusScriptHash = (bech325) => {
  try {
    const enterpriseAddress = toEnterpriseAddress(bech325);
    const scriptHash = enterpriseAddress?.getPaymentCredential().hash;
    if (scriptHash !== void 0) return scriptHash.toString();
    throw new Error(`Couldn't resolve script hash from address: ${bech325}`);
  } catch (error) {
    throw new Error(`An error occurred during resolveScriptHash: ${error}.`);
  }
};
var resolvePoolId = (hash) => {
  return PoolId.fromKeyHash(Ed25519KeyHashHex2(hash)).toString();
};
var resolvePrivateKey = (words) => {
  const buildBip32PrivateKey2 = (entropy2, password = "") => {
    return Bip32PrivateKey2.fromBip39Entropy(
      Buffer.from(toBytes4(entropy2)),
      fromUTF8(password)
    );
  };
  const entropy = mnemonicToEntropy(words.join(" "));
  const bip32PrivateKey = buildBip32PrivateKey2(entropy);
  const bytes = base323.encode(bip32PrivateKey.bytes());
  const bech32PrivateKey = bech323.encode("xprv", bytes, 1023);
  return bech32PrivateKey;
};
var resolveScriptRef = (script) => {
  return toScriptRef(script).toCbor().toString();
};
var resolveRewardAddress = (bech325) => {
  try {
    const address = toAddress(bech325);
    const baseAddress = toBaseAddress(bech325);
    const stakeKeyHash = baseAddress?.getStakeCredential().hash;
    if (stakeKeyHash !== void 0)
      return buildRewardAddress(address.getNetworkId(), stakeKeyHash).toAddress().toBech32().toString();
    throw new Error(`Couldn't resolve reward address from address: ${bech325}`);
  } catch (error) {
    throw new Error(`An error occurred during resolveRewardAddress: ${error}.`);
  }
};
var resolveStakeKeyHash = (bech325) => {
  try {
    const stakeKeyHash = [
      toBaseAddress(bech325)?.getStakeCredential().hash,
      toRewardAddress(bech325)?.getPaymentCredential().hash
    ].find((kh) => kh !== void 0);
    if (stakeKeyHash !== void 0) return stakeKeyHash.toString();
    throw new Error(`Couldn't resolve stake key hash from address: ${bech325}`);
  } catch (error) {
    throw new Error(`An error occurred during resolveStakeKeyHash: ${error}.`);
  }
};
var resolveTxHash = (txHex) => {
  const txBody = deserializeTx(txHex).body();
  const hash = blake2b5(blake2b5.BYTES).update(hexToBytes(txBody.toCbor())).digest();
  return Cardano2.TransactionId.fromHexBlob(HexBlob6.fromBytes(hash)).toString();
};
var resolveScriptHashDRepId = (scriptHash) => {
  return DRepID.cip129FromCredential({
    type: Cardano2.CredentialType.ScriptHash,
    hash: Hash28ByteBase162(scriptHash)
  }).toString();
};
var resolveEd25519KeyHash = (bech325) => {
  try {
    const keyHash = [
      toBaseAddress(bech325)?.getPaymentCredential().hash,
      toEnterpriseAddress(bech325)?.getPaymentCredential().hash
    ].find((kh) => kh !== void 0);
    if (keyHash !== void 0) return keyHash.toString();
    throw new Error(`Couldn't resolve key hash from address: ${bech325}`);
  } catch (error) {
    throw new Error(
      `An error occurred during resolveEd25519KeyHash: ${error}.`
    );
  }
};

// src/serializer/index.ts
import { Serialization as Serialization6 } from "@cardano-sdk/core";
import { HexBlob as HexBlob8 } from "@cardano-sdk/util";
import {
  Cbor,
  CborArray,
  CborBytes,
  CborString,
  CborTag,
  CborUInt
} from "@harmoniclabs/cbor";
import base324 from "base32-encoding";
import { bech32 as bech324 } from "bech32";
import {
  DEFAULT_PROTOCOL_PARAMETERS,
  DEFAULT_V1_COST_MODEL_LIST,
  DEFAULT_V2_COST_MODEL_LIST,
  DEFAULT_V3_COST_MODEL_LIST,
  fromUTF8 as fromUTF82,
  mnemonicToEntropy as mnemonicToEntropy2,
  toBytes as toBytes5
} from "@meshsdk/common";

// src/utils/certificate.ts
import { Cardano as Cardano3, Serialization as Serialization4 } from "@cardano-sdk/core";
var toCardanoCert = (cert) => {
  switch (cert.type) {
    case "RegisterPool": {
      let relays = [];
      for (const relay of cert.poolParams.relays) {
        switch (relay.type) {
          case "SingleHostAddr": {
            relays.push(
              Serialization4.Relay.newSingleHostAddr(
                new Serialization4.SingleHostAddr(
                  relay.port,
                  relay.IPV4,
                  relay.IPV6
                )
              )
            );
            break;
          }
          case "SingleHostName": {
            relays.push(
              Serialization4.Relay.newSingleHostName(
                new Serialization4.SingleHostName(relay.domainName, relay.port)
              )
            );
            break;
          }
          case "MultiHostName": {
            relays.push(
              Serialization4.Relay.newMultiHostName(
                new Serialization4.MultiHostName(relay.domainName)
              )
            );
            break;
          }
        }
      }
      let poolOwners = Serialization4.CborSet.fromCore([], Serialization4.Hash.fromCore);
      let poolOwnersValues = [...poolOwners.values()];
      for (const poolOwner of cert.poolParams.owners) {
        poolOwnersValues.push(
          Serialization4.Hash.fromCore(Ed25519KeyHashHex2(poolOwner))
        );
      }
      poolOwners.setValues(poolOwnersValues);
      const rewardAddress = Cardano3.RewardAddress.fromAddress(
        Cardano3.Address.fromBech32(cert.poolParams.rewardAddress)
      );
      if (rewardAddress === void 0) {
        throw new Error(
          "Error parsing reward address, it is expected to be in bech32 format"
        );
      }
      const metadata = cert.poolParams.metadata ? new Serialization4.PoolMetadata(
        cert.poolParams.metadata.URL,
        Crypto2.Hash32ByteBase16(cert.poolParams.metadata.hash)
      ) : void 0;
      return Certificate.newPoolRegistration(
        new Serialization4.PoolRegistration(
          new Serialization4.PoolParams(
            Ed25519KeyHashHex2(cert.poolParams.operator),
            Cardano3.VrfVkHex(cert.poolParams.vrfKeyHash),
            BigInt(cert.poolParams.pledge),
            BigInt(cert.poolParams.cost),
            new Serialization4.UnitInterval(
              BigInt(cert.poolParams.margin[0]),
              BigInt(cert.poolParams.margin[1])
            ),
            rewardAddress,
            poolOwners,
            relays,
            metadata
          )
        )
      );
    }
    case "RegisterStake": {
      const rewardAddress = Cardano3.RewardAddress.fromAddress(
        Cardano3.Address.fromBech32(cert.stakeKeyAddress)
      );
      if (rewardAddress === void 0) {
        throw new Error(
          "Error parsing reward address, it is expected to be in bech32 format"
        );
      }
      return Certificate.newStakeRegistration(
        new Serialization4.StakeRegistration(
          rewardAddress.getPaymentCredential()
        )
      );
    }
    case "DelegateStake": {
      const rewardAddress = Cardano3.RewardAddress.fromAddress(
        Cardano3.Address.fromBech32(cert.stakeKeyAddress)
      );
      if (rewardAddress === void 0) {
        throw new Error(
          "Error parsing reward address, it is expected to be in bech32 format"
        );
      }
      return Certificate.newStakeDelegation(
        new Serialization4.StakeDelegation(
          rewardAddress.getPaymentCredential(),
          Ed25519KeyHashHex2(cert.poolId)
        )
      );
    }
    case "DeregisterStake": {
      const rewardAddress = Cardano3.RewardAddress.fromAddress(
        Cardano3.Address.fromBech32(cert.stakeKeyAddress)
      );
      if (rewardAddress === void 0) {
        throw new Error(
          "Error parsing reward address, it is expected to be in bech32 format"
        );
      }
      return Certificate.newStakeDeregistration(
        new Serialization4.StakeDeregistration(
          rewardAddress.getPaymentCredential()
        )
      );
    }
    case "RetirePool": {
      return Certificate.newPoolRetirement(
        new Serialization4.PoolRetirement(
          Ed25519KeyHashHex2(cert.poolId),
          Cardano3.EpochNo(cert.epoch)
        )
      );
    }
    case "VoteDelegation": {
      const rewardAddress = Cardano3.RewardAddress.fromAddress(
        Cardano3.Address.fromBech32(cert.stakeKeyAddress)
      );
      if (rewardAddress === void 0) {
        throw new Error(
          "Error parsing reward address, it is expected to be in bech32 format"
        );
      }
      if (cert.drep.dRepId !== void 0) {
        return Certificate.newVoteDelegationCert(
          new Serialization4.VoteDelegation(
            rewardAddress.getPaymentCredential(),
            toDRep(cert.drep.dRepId)
          )
        );
      } else if (cert.drep.alwaysAbstain !== void 0) {
        return Certificate.newVoteDelegationCert(
          new Serialization4.VoteDelegation(
            rewardAddress.getPaymentCredential(),
            Serialization4.DRep.newAlwaysAbstain()
          )
        );
      } else if (cert.drep.alwaysNoConfidence !== void 0) {
        return Certificate.newVoteDelegationCert(
          new Serialization4.VoteDelegation(
            rewardAddress.getPaymentCredential(),
            Serialization4.DRep.newAlwaysNoConfidence()
          )
        );
      } else {
        throw new Error("Malformed DRep type");
      }
    }
    case "StakeAndVoteDelegation": {
      const rewardAddress = Cardano3.RewardAddress.fromAddress(
        Cardano3.Address.fromBech32(cert.stakeKeyAddress)
      );
      if (rewardAddress === void 0) {
        throw new Error(
          "Error parsing reward address, it is expected to be in bech32 format"
        );
      }
      if (cert.drep.dRepId !== void 0) {
        return Certificate.newStakeVoteDelegationCert(
          new Serialization4.StakeVoteDelegation(
            rewardAddress.getPaymentCredential(),
            toDRep(cert.drep.dRepId),
            Ed25519KeyHashHex2(cert.poolKeyHash)
          )
        );
      } else if (cert.drep.alwaysAbstain !== void 0) {
        return Certificate.newStakeVoteDelegationCert(
          new Serialization4.StakeVoteDelegation(
            rewardAddress.getPaymentCredential(),
            Serialization4.DRep.newAlwaysAbstain(),
            Ed25519KeyHashHex2(cert.poolKeyHash)
          )
        );
      } else if (cert.drep.alwaysNoConfidence !== void 0) {
        return Certificate.newStakeVoteDelegationCert(
          new Serialization4.StakeVoteDelegation(
            rewardAddress.getPaymentCredential(),
            Serialization4.DRep.newAlwaysNoConfidence(),
            Ed25519KeyHashHex2(cert.poolKeyHash)
          )
        );
      } else {
        throw new Error("Malformed DRep type");
      }
    }
    case "StakeRegistrationAndDelegation": {
      const rewardAddress = Cardano3.RewardAddress.fromAddress(
        Cardano3.Address.fromBech32(cert.stakeKeyAddress)
      );
      if (rewardAddress === void 0) {
        throw new Error(
          "Error parsing reward address, it is expected to be in bech32 format"
        );
      }
      return Certificate.newStakeRegistrationDelegationCert(
        new Serialization4.StakeRegistrationDelegation(
          rewardAddress.getPaymentCredential(),
          BigInt(cert.coin),
          Ed25519KeyHashHex2(cert.poolKeyHash)
        )
      );
    }
    case "VoteRegistrationAndDelegation": {
      const rewardAddress = Cardano3.RewardAddress.fromAddress(
        Cardano3.Address.fromBech32(cert.stakeKeyAddress)
      );
      if (rewardAddress === void 0) {
        throw new Error(
          "Error parsing reward address, it is expected to be in bech32 format"
        );
      }
      if (cert.drep.dRepId !== void 0) {
        return Certificate.newVoteRegistrationDelegationCert(
          new Serialization4.VoteRegistrationDelegation(
            rewardAddress.getPaymentCredential(),
            BigInt(cert.coin),
            toDRep(cert.drep.dRepId)
          )
        );
      } else if (cert.drep.alwaysAbstain !== void 0) {
        return Certificate.newVoteRegistrationDelegationCert(
          new Serialization4.VoteRegistrationDelegation(
            rewardAddress.getPaymentCredential(),
            BigInt(cert.coin),
            Serialization4.DRep.newAlwaysAbstain()
          )
        );
      } else if (cert.drep.alwaysNoConfidence !== void 0) {
        return Certificate.newVoteRegistrationDelegationCert(
          new Serialization4.VoteRegistrationDelegation(
            rewardAddress.getPaymentCredential(),
            BigInt(cert.coin),
            Serialization4.DRep.newAlwaysNoConfidence()
          )
        );
      } else {
        throw new Error("Malformed DRep type");
      }
    }
    case "StakeVoteRegistrationAndDelegation": {
      const rewardAddress = Cardano3.RewardAddress.fromAddress(
        Cardano3.Address.fromBech32(cert.stakeKeyAddress)
      );
      if (rewardAddress === void 0) {
        throw new Error(
          "Error parsing reward address, it is expected to be in bech32 format"
        );
      }
      if (cert.drep.dRepId !== void 0) {
        return Certificate.newStakeVoteDelegationCert(
          new Serialization4.StakeVoteDelegation(
            rewardAddress.getPaymentCredential(),
            toDRep(cert.drep.dRepId),
            Ed25519KeyHashHex2(cert.poolKeyHash)
          )
        );
      } else if (cert.drep.alwaysAbstain !== void 0) {
        return Certificate.newStakeVoteDelegationCert(
          new Serialization4.StakeVoteDelegation(
            rewardAddress.getPaymentCredential(),
            Serialization4.DRep.newAlwaysAbstain(),
            Ed25519KeyHashHex2(cert.poolKeyHash)
          )
        );
      } else if (cert.drep.alwaysNoConfidence !== void 0) {
        return Certificate.newStakeVoteDelegationCert(
          new Serialization4.StakeVoteDelegation(
            rewardAddress.getPaymentCredential(),
            Serialization4.DRep.newAlwaysNoConfidence(),
            Ed25519KeyHashHex2(cert.poolKeyHash)
          )
        );
      } else {
        throw new Error("Malformed DRep type");
      }
    }
    case "CommitteeHotAuth": {
      const hotCred = Cardano3.Address.fromBech32(
        cert.committeeHotKeyAddress
      ).getProps().paymentPart;
      const coldCred = Cardano3.Address.fromBech32(
        cert.committeeColdKeyAddress
      ).getProps().paymentPart;
      if (!hotCred || !coldCred) {
        throw new Error("Malformed hot/cold credential");
      }
      return Certificate.newAuthCommitteeHotCert(
        new Serialization4.AuthCommitteeHot(coldCred, hotCred)
      );
    }
    case "CommitteeColdResign": {
      const coldCred = Cardano3.Address.fromBech32(
        cert.committeeColdKeyAddress
      ).getProps().paymentPart;
      if (!coldCred) {
        throw new Error("Malformed hot/cold credential");
      }
      let anchor = void 0;
      if (cert.anchor) {
        anchor = new Serialization4.Anchor(
          cert.anchor.anchorUrl,
          Hash32ByteBase162(cert.anchor.anchorDataHash)
        );
      }
      return Certificate.newResignCommitteeColdCert(
        new Serialization4.ResignCommitteeCold(coldCred, anchor)
      );
    }
    case "DRepRegistration": {
      let anchor = void 0;
      if (cert.anchor) {
        anchor = new Serialization4.Anchor(
          cert.anchor.anchorUrl,
          Hash32ByteBase162(cert.anchor.anchorDataHash)
        );
      }
      const coreDRep = toDRep(cert.drepId).toCore();
      if (Cardano3.isDRepCredential(coreDRep)) {
        return Certificate.newRegisterDelegateRepresentativeCert(
          new Serialization4.RegisterDelegateRepresentative(
            coreDRep,
            BigInt(cert.coin),
            anchor
          )
        );
      } else {
        throw new Error("DRepId must be a Credential");
      }
    }
    case "DRepDeregistration": {
      const coreDRep = toDRep(cert.drepId).toCore();
      if (Cardano3.isDRepCredential(coreDRep)) {
        return Certificate.newUnregisterDelegateRepresentativeCert(
          new Serialization4.UnregisterDelegateRepresentative(
            coreDRep,
            BigInt(cert.coin)
          )
        );
      } else {
        throw new Error("DRepId must be a Credential");
      }
    }
    case "DRepUpdate": {
      let anchor = void 0;
      if (cert.anchor) {
        anchor = new Serialization4.Anchor(
          cert.anchor.anchorUrl,
          Hash32ByteBase162(cert.anchor.anchorDataHash)
        );
      }
      const coreDRep = toDRep(cert.drepId).toCore();
      if (Cardano3.isDRepCredential(coreDRep)) {
        return Certificate.newUpdateDelegateRepresentativeCert(
          new Serialization4.UpdateDelegateRepresentative(coreDRep, anchor)
        );
      } else {
        throw new Error("DRepId must be a Credential");
      }
    }
  }
};

// src/utils/fee.ts
var calculateFees = (minFeeA, minFeeB, minFeeRefScriptCostPerByte, priceMem, priceStep, tx, refScriptSize) => {
  let fee = minFeeB + tx.toCbor().length / 2 * minFeeA;
  const tierSize = 25600;
  let currentRefScriptSize = refScriptSize;
  let multiplier = 1.2;
  while (currentRefScriptSize >= tierSize) {
    fee += tierSize * multiplier * minFeeRefScriptCostPerByte;
    currentRefScriptSize -= tierSize;
    multiplier *= multiplier;
  }
  if (currentRefScriptSize > 0) {
    fee += currentRefScriptSize * multiplier * minFeeRefScriptCostPerByte;
  }
  let scriptFee = BigInt(0);
  let priceMemNumerator = priceMem;
  let priceMemDenominator = 1;
  while (priceMemNumerator % 1) {
    priceMemNumerator *= 10;
    priceMemDenominator *= 10;
  }
  let priceStepNumerator = priceStep;
  let priceStepDenominator = 1;
  while (priceStepNumerator % 1) {
    priceStepNumerator *= 10;
    priceStepDenominator *= 10;
  }
  if (tx.witnessSet().redeemers()) {
    for (const redeemer of tx.witnessSet().redeemers().values()) {
      scriptFee += redeemer.exUnits().mem() * BigInt(priceMemNumerator.toString()) / BigInt(priceMemDenominator.toString()) + BigInt(1);
      scriptFee += redeemer.exUnits().steps() * BigInt(priceStepNumerator.toString()) / BigInt(priceStepDenominator.toString()) + BigInt(1);
    }
  }
  return BigInt(fee) + scriptFee;
};

// src/utils/metadata.ts
var toCardanoMetadataMap = (metadata) => {
  let cardanoMetadataMap = /* @__PURE__ */ new Map();
  metadata.forEach((val, key) => {
    cardanoMetadataMap.set(key, toCardanoMetadatum(val));
  });
  return cardanoMetadataMap;
};
var toCardanoMetadatum = (metadatum) => {
  if (typeof metadatum === "number") {
    return TransactionMetadatum.newInteger(BigInt(metadatum));
  } else if (typeof metadatum === "string") {
    return TransactionMetadatum.newText(metadatum);
  } else if (typeof metadatum === "bigint") {
    return TransactionMetadatum.newInteger(metadatum);
  } else if (metadatum instanceof Uint8Array) {
    return TransactionMetadatum.newBytes(metadatum);
  } else if (metadatum instanceof Map) {
    const result = new MetadatumMap();
    metadatum.forEach((value, key) => {
      result.insert(toCardanoMetadatum(key), toCardanoMetadatum(value));
    });
    return TransactionMetadatum.newMap(result);
  } else if (Array.isArray(metadatum)) {
    const result = new MetadatumList();
    metadatum.forEach((val) => {
      result.add(toCardanoMetadatum(val));
    });
    return TransactionMetadatum.newList(result);
  } else {
    throw new Error("metadatumToObj: Unsupported Metadatum type");
  }
};

// src/utils/script-data-hash.ts
import { Serialization as Serialization5 } from "@cardano-sdk/core";
import * as Crypto3 from "@cardano-sdk/crypto";
import { Hash32ByteBase16 as Hash32ByteBase163 } from "@cardano-sdk/crypto";
import { HexBlob as HexBlob7 } from "@cardano-sdk/util";
var CBOR_EMPTY_LIST = new Uint8Array([128]);
var CBOR_EMPTY_MAP = new Uint8Array([160]);
var getCborEncodedArray = (items) => {
  const writer = new Serialization5.CborWriter();
  writer.writeStartArray(items.length);
  for (const item of items) {
    writer.writeEncodedValue(Buffer.from(item.toCbor(), "hex"));
  }
  return writer.encode();
};
var hashScriptData = (costModels, redemeers, datums) => {
  const writer = new Serialization5.CborWriter();
  if (datums && datums.length > 0 && (!redemeers || redemeers.length === 0)) {
    writer.writeEncodedValue(CBOR_EMPTY_LIST);
    writer.writeEncodedValue(getCborEncodedArray(datums));
    writer.writeEncodedValue(CBOR_EMPTY_MAP);
  } else {
    if (!redemeers || redemeers.length === 0) return void 0;
    writer.writeEncodedValue(getCborEncodedArray(redemeers));
    if (datums && datums.length > 0)
      writer.writeEncodedValue(getCborEncodedArray(datums));
    writer.writeEncodedValue(
      Buffer.from(costModels.languageViewsEncoding(), "hex")
    );
  }
  return Hash32ByteBase163.fromHexBlob(
    HexBlob7.fromBytes(
      Crypto3.blake2b(Crypto3.blake2b.BYTES).update(writer.encode()).digest()
    )
  );
};

// src/serializer/index.ts
var CardanoSDKSerializer = class {
  verbose;
  protocolParams;
  constructor(protocolParams, verbose = false) {
    this.protocolParams = protocolParams || DEFAULT_PROTOCOL_PARAMETERS;
    this.verbose = verbose;
  }
  serializeRewardAddress(stakeKeyHash, isScriptHash, network_id) {
    return RewardAddress.fromCredentials(network_id ?? 0, {
      type: isScriptHash ? CredentialType.ScriptHash : CredentialType.KeyHash,
      hash: Hash28ByteBase162(stakeKeyHash)
    }).toAddress().toBech32();
  }
  serializePoolId(hash) {
    return PoolId.fromKeyHash(Ed25519KeyHashHex2(hash)).toString();
  }
  serializeAddress(address, networkId) {
    let paymentCred = void 0;
    let stakeCred;
    if (address.pubKeyHash && address.pubKeyHash !== "") {
      paymentCred = {
        type: CredentialType.KeyHash,
        hash: Hash28ByteBase162(address.pubKeyHash)
      };
    } else if (address.scriptHash && address.scriptHash !== "") {
      paymentCred = {
        type: CredentialType.ScriptHash,
        hash: Hash28ByteBase162(address.scriptHash)
      };
    }
    if (address.stakeCredentialHash && address.stakeCredentialHash !== "") {
      stakeCred = {
        type: CredentialType.KeyHash,
        hash: Hash28ByteBase162(address.stakeCredentialHash)
      };
    } else if (address.stakeScriptCredentialHash) {
      stakeCred = {
        type: CredentialType.ScriptHash,
        hash: Hash28ByteBase162(address.stakeScriptCredentialHash)
      };
    }
    let type = AddressType.BasePaymentKeyStakeKey;
    if (paymentCred && stakeCred) {
      if (paymentCred.type === CredentialType.KeyHash && stakeCred.type === CredentialType.KeyHash) {
        type = AddressType.BasePaymentKeyStakeKey;
      } else if (paymentCred.type === CredentialType.KeyHash && stakeCred.type === CredentialType.ScriptHash) {
        type = AddressType.BasePaymentKeyStakeScript;
      } else if (paymentCred.type === CredentialType.ScriptHash && stakeCred.type === CredentialType.KeyHash) {
        type = AddressType.BasePaymentScriptStakeKey;
      } else if (paymentCred.type === CredentialType.ScriptHash && stakeCred.type === CredentialType.ScriptHash) {
        type = AddressType.BasePaymentScriptStakeScript;
      }
    } else if (paymentCred) {
      if (paymentCred.type === CredentialType.KeyHash) {
        type = AddressType.EnterpriseKey;
      } else if (paymentCred.type === CredentialType.ScriptHash) {
        type = AddressType.EnterpriseScript;
      }
    } else if (stakeCred) {
      if (stakeCred.type === CredentialType.KeyHash) {
        type = AddressType.RewardKey;
      } else if (stakeCred.type === CredentialType.ScriptHash) {
        type = AddressType.RewardScript;
      }
    }
    return new Address({
      type,
      networkId: networkId ?? 0,
      paymentPart: paymentCred,
      delegationPart: stakeCred
    }).toBech32();
  }
  serializeData(data) {
    const plutusData = fromBuilderToPlutusData(data);
    return plutusData.toCbor().toString();
  }
  deserializer = {
    key: {
      deserializeAddress: function(bech325) {
        const address = Address.fromBech32(bech325);
        const addressProps = address.getProps();
        return {
          pubKeyHash: addressProps.paymentPart?.type === CredentialType.KeyHash ? addressProps.paymentPart?.hash ?? "" : "",
          scriptHash: addressProps.paymentPart?.type === CredentialType.ScriptHash ? addressProps.paymentPart?.hash ?? "" : "",
          stakeCredentialHash: addressProps.delegationPart?.type === CredentialType.KeyHash ? addressProps.paymentPart?.hash ?? "" : "",
          stakeScriptCredentialHash: addressProps.delegationPart?.type === CredentialType.ScriptHash ? addressProps.paymentPart?.hash ?? "" : ""
        };
      }
    },
    script: {
      deserializeNativeScript: function(script) {
        const cardanoNativeScript = toNativeScript(script);
        return {
          scriptHash: cardanoNativeScript.hash().toString(),
          scriptCbor: cardanoNativeScript.toCbor().toString()
        };
      },
      deserializePlutusScript: function(script) {
        let cardanoPlutusScript;
        switch (script.version) {
          case "V1": {
            cardanoPlutusScript = new PlutusV1Script(HexBlob8(script.code));
            break;
          }
          case "V2": {
            cardanoPlutusScript = new PlutusV2Script(HexBlob8(script.code));
            break;
          }
          case "V3": {
            cardanoPlutusScript = new PlutusV3Script(HexBlob8(script.code));
            break;
          }
        }
        return {
          scriptHash: cardanoPlutusScript.hash().toString(),
          scriptCbor: cardanoPlutusScript.toCbor().toString()
        };
      }
    },
    cert: {
      deserializePoolId: function(poolId) {
        const cardanoPoolId = PoolId(poolId);
        return PoolId.toKeyHash(cardanoPoolId).toString();
      }
    }
  };
  resolver = {
    keys: {
      resolveStakeKeyHash: function(bech325) {
        const cardanoAddress = toAddress(bech325);
        return cardanoAddress.asReward()?.getPaymentCredential().type === CredentialType.KeyHash ? cardanoAddress.asReward().getPaymentCredential().hash : "";
      },
      resolvePrivateKey: function(words) {
        const buildBip32PrivateKey2 = (entropy2, password = "") => {
          return Bip32PrivateKey2.fromBip39Entropy(
            Buffer.from(toBytes5(entropy2)),
            fromUTF82(password)
          );
        };
        const entropy = mnemonicToEntropy2(words.join(" "));
        const bip32PrivateKey = buildBip32PrivateKey2(entropy);
        const bytes = base324.encode(bip32PrivateKey.bytes());
        const bech32PrivateKey = bech324.encode("xprv", bytes, 1023);
        return bech32PrivateKey;
      },
      resolveRewardAddress: function(bech325) {
        const cardanoAddress = toAddress(bech325);
        const addressProps = cardanoAddress.getProps();
        if (!addressProps.delegationPart) {
          return "";
        }
        return RewardAddress.fromCredentials(
          cardanoAddress.getNetworkId(),
          addressProps.delegationPart
        ).toAddress().toBech32() ?? "";
      },
      resolveEd25519KeyHash: function(bech325) {
        const cardanoAddress = toAddress(bech325);
        const addressProps = cardanoAddress.getProps();
        if (!addressProps.paymentPart) {
          return "";
        }
        return addressProps.paymentPart.hash.toString();
      }
    },
    tx: {
      resolveTxHash: function(txHex) {
        return Transaction.fromCbor(Serialization6.TxCBOR(txHex)).getId();
      }
    },
    data: {
      resolveDataHash: function(data) {
        return fromBuilderToPlutusData({ type: "Mesh", content: data }).hash();
      }
    },
    script: {
      resolveScriptRef: function(script) {
        if ("code" in script) {
          let versionByte;
          switch (script.version) {
            case "V1": {
              versionByte = 1;
              break;
            }
            case "V2": {
              versionByte = 2;
              break;
            }
            case "V3": {
              versionByte = 3;
              break;
            }
          }
          let taggedScript = new CborTag(
            24,
            Cbor.parse(
              CborString.fromCborObj(
                new CborBytes(
                  Cbor.encode(
                    new CborArray([
                      new CborUInt(versionByte),
                      new CborString(script.code).toCborObj()
                    ])
                  ).toBuffer()
                )
              )
            )
          );
          return Cbor.encode(taggedScript).toString();
        } else {
          const nativeScript = toNativeScript(script);
          let taggedScript = new CborTag(
            24,
            Cbor.parse(
              CborString.fromCborObj(
                new CborBytes(
                  Cbor.encode(
                    new CborArray([
                      new CborUInt(0),
                      new CborString(nativeScript.toCbor()).toCborObj()
                    ])
                  ).toBuffer()
                )
              )
            )
          );
          return Cbor.encode(taggedScript).toString();
        }
      }
    }
  };
  serializeTxBody = (txBuilderBody, protocolParams) => {
    if (this.verbose) {
      console.log(
        "txBodyJson",
        JSON.stringify(txBuilderBody, (key, val) => {
          if (key === "extraInputs") return void 0;
          if (key === "selectionConfig") return void 0;
          return val;
        })
      );
    }
    const serializerCore = new CardanoSDKSerializerCore(
      protocolParams ?? this.protocolParams
    );
    return serializerCore.coreSerializeTxBody(txBuilderBody);
  };
  addSigningKeys = (txHex, signingKeys) => {
    let cardanoTx = Transaction.fromCbor(Serialization6.TxCBOR(txHex));
    let currentWitnessSet = cardanoTx.witnessSet();
    let currentWitnessSetVkeys = currentWitnessSet.vkeys();
    let currentWitnessSetVkeysValues = currentWitnessSetVkeys ? [...currentWitnessSetVkeys.values()] : [];
    for (let i = 0; i < signingKeys.length; i++) {
      let keyHex = signingKeys[i];
      if (keyHex) {
        if (keyHex.length === 68 && keyHex.substring(0, 4) === "5820") {
          keyHex = keyHex.substring(4);
        }
        const cardanoSigner = StricaPrivateKey.fromSecretKey(
          Buffer.from(keyHex, "hex")
        );
        const signature = cardanoSigner.sign(
          Buffer.from(cardanoTx.getId(), "hex")
        );
        currentWitnessSetVkeysValues.push(
          new VkeyWitness(
            Ed25519PublicKeyHex2(
              cardanoSigner.toPublicKey().toBytes().toString("hex")
            ),
            Ed25519SignatureHex2(signature.toString("hex"))
          )
        );
      }
    }
    currentWitnessSet.setVkeys(
      Serialization6.CborSet.fromCore(
        currentWitnessSetVkeysValues.map((vkw) => vkw.toCore()),
        VkeyWitness.fromCore
      )
    );
    cardanoTx.setWitnessSet(currentWitnessSet);
    return cardanoTx.toCbor();
  };
};
var CardanoSDKSerializerCore = class {
  txBody;
  txWitnessSet;
  txAuxilliaryData;
  utxoContext = /* @__PURE__ */ new Map();
  mintRedeemers = /* @__PURE__ */ new Map();
  scriptsProvided = /* @__PURE__ */ new Set();
  datumsProvided = /* @__PURE__ */ new Set();
  usedLanguages = {
    [0]: false,
    [1]: false,
    [2]: false
  };
  protocolParams;
  refScriptSize;
  constructor(protocolParams) {
    this.protocolParams = protocolParams || DEFAULT_PROTOCOL_PARAMETERS;
    this.txBody = new TransactionBody(
      Serialization6.CborSet.fromCore([], TransactionInput.fromCore),
      [],
      BigInt(0),
      void 0
    );
    this.refScriptSize = 0;
    this.txWitnessSet = new TransactionWitnessSet();
    this.txAuxilliaryData = new AuxilliaryData();
  }
  coreSerializeTxBody = (txBuilderBody) => {
    const {
      inputs,
      outputs,
      collaterals,
      requiredSignatures,
      referenceInputs,
      mints,
      changeAddress,
      metadata,
      validityRange,
      certificates,
      withdrawals
    } = txBuilderBody;
    this.addAllInputs(inputs);
    this.addAllOutputs(this.sanitizeOutputs(outputs));
    this.addAllMints(mints);
    this.addAllCerts(certificates);
    this.addAllWithdrawals(withdrawals);
    this.addAllCollateralInputs(collaterals);
    this.addAllReferenceInputs(referenceInputs);
    this.removeInputRefInputOverlap();
    this.setValidityInterval(validityRange);
    this.addAllRequiredSignatures(requiredSignatures);
    if (metadata.size > 0) {
      this.addMetadata(metadata);
    }
    this.buildWitnessSet();
    this.balanceTx(changeAddress);
    return new Transaction(
      this.txBody,
      this.txWitnessSet,
      this.txAuxilliaryData
    ).toCbor();
  };
  sanitizeOutputs = (outputs) => {
    for (let i = 0; i < outputs.length; i++) {
      let currentOutput = outputs[i];
      let lovelaceFound = false;
      for (let j = 0; j < currentOutput.amount.length; j++) {
        let outputAmount = currentOutput.amount[j];
        if (outputAmount?.unit == "" || outputAmount?.unit == "lovelace") {
          lovelaceFound = true;
          if (outputAmount?.quantity == "0" || outputAmount?.quantity == "") {
            outputAmount.unit = "lovelace";
            outputAmount.quantity = "10000000";
            let dummyCardanoOutput = this.toCardanoOutput(
              currentOutput
            );
            let minUtxoValue = (160 + dummyCardanoOutput.toCbor().length / 2 + 1) * this.protocolParams.coinsPerUtxoSize;
            outputAmount.quantity = minUtxoValue.toString();
          }
        }
        if (!lovelaceFound) {
          let currentAmount = {
            unit: "lovelace",
            quantity: "10000000"
          };
          currentOutput.amount.push(currentAmount);
          let dummyCardanoOutput = this.toCardanoOutput(
            currentOutput
          );
          let minUtxoValue = (160 + dummyCardanoOutput.toCbor().length / 2 + 1) * this.protocolParams.coinsPerUtxoSize;
          currentAmount.quantity = minUtxoValue.toString();
        }
      }
    }
    return outputs;
  };
  addAllInputs = (inputs) => {
    for (let i = 0; i < inputs.length; i += 1) {
      const currentTxIn = inputs[i];
      if (!currentTxIn) continue;
      switch (currentTxIn.type) {
        case "PubKey":
          this.addTxIn(currentTxIn);
          break;
        case "Script":
          this.addScriptTxIn(
            currentTxIn,
            i
          );
          break;
        case "SimpleScript":
          this.addSimpleScriptTxIn(
            currentTxIn
          );
      }
    }
  };
  addTxIn = (currentTxIn) => {
    let cardanoTxIn = new TransactionInput(
      TransactionId(currentTxIn.txIn.txHash),
      BigInt(currentTxIn.txIn.txIndex)
    );
    const inputs = this.txBody.inputs();
    const txInputsList = [...inputs.values()];
    if (txInputsList.find((input) => {
      input.index() == cardanoTxIn.index() && input.transactionId == cardanoTxIn.transactionId;
    })) {
      throw new Error("Duplicate input added to tx body");
    }
    txInputsList.push(cardanoTxIn);
    inputs.setValues(txInputsList);
    const cardanoTxOut = new TransactionOutput(
      toCardanoAddress(currentTxIn.txIn.address),
      toValue(currentTxIn.txIn.amount)
    );
    this.utxoContext.set(cardanoTxIn, cardanoTxOut);
    this.txBody.setInputs(inputs);
  };
  addScriptTxIn = (currentTxIn, index) => {
    this.addTxIn({
      type: "PubKey",
      txIn: currentTxIn.txIn
    });
    if (!currentTxIn.scriptTxIn.scriptSource) {
      throw new Error("A script input had no script source");
    }
    if (!currentTxIn.scriptTxIn.datumSource) {
      throw new Error("A script input had no datum source");
    }
    if (!currentTxIn.scriptTxIn.redeemer) {
      throw new Error("A script input had no redeemer");
    }
    if (currentTxIn.scriptTxIn.scriptSource.type === "Provided") {
      this.addProvidedPlutusScript(currentTxIn.scriptTxIn.scriptSource.script);
    } else if (currentTxIn.scriptTxIn.scriptSource.type === "Inline") {
      this.addScriptRef(currentTxIn.scriptTxIn.scriptSource);
    }
    if (currentTxIn.scriptTxIn.datumSource.type === "Provided") {
      this.datumsProvided.add(
        fromBuilderToPlutusData(currentTxIn.scriptTxIn.datumSource.data)
      );
    } else if (currentTxIn.scriptTxIn.datumSource.type === "Inline") {
      let referenceInputs = this.txBody.referenceInputs() ?? Serialization6.CborSet.fromCore([], TransactionInput.fromCore);
      let referenceInputsList = [...referenceInputs.values()];
      referenceInputsList.push(
        new TransactionInput(
          TransactionId(currentTxIn.txIn.txHash),
          BigInt(currentTxIn.txIn.txIndex)
        )
      );
      referenceInputs.setValues(referenceInputsList);
      this.txBody.setReferenceInputs(referenceInputs);
    }
    let exUnits = currentTxIn.scriptTxIn.redeemer.exUnits;
    let redeemers = this.txWitnessSet.redeemers() ?? Redeemers.fromCore([]);
    let redeemersList = [...redeemers.values()];
    redeemersList.push(
      new Redeemer(
        RedeemerTag.Spend,
        BigInt(index),
        fromBuilderToPlutusData(currentTxIn.scriptTxIn.redeemer.data),
        new ExUnits(BigInt(exUnits.mem), BigInt(exUnits.steps))
      )
    );
    redeemers.setValues(redeemersList);
    this.txWitnessSet.setRedeemers(redeemers);
  };
  addSimpleScriptTxIn = (currentTxIn) => {
    this.addTxIn({
      type: "PubKey",
      txIn: currentTxIn.txIn
    });
    if (!currentTxIn.simpleScriptTxIn.scriptSource) {
      throw new Error("A native script input had no script source");
    }
    if (currentTxIn.simpleScriptTxIn.scriptSource.type === "Provided") {
      this.scriptsProvided.add(
        Script.newNativeScript(
          NativeScript.fromCbor(
            HexBlob8(currentTxIn.simpleScriptTxIn.scriptSource.scriptCode)
          )
        ).toCbor()
      );
    } else if (currentTxIn.simpleScriptTxIn.scriptSource.type === "Inline") {
      this.addSimpleScriptRef(currentTxIn.simpleScriptTxIn.scriptSource);
    }
  };
  addAllOutputs = (outputs) => {
    for (let i = 0; i < outputs.length; i++) {
      this.addOutput(outputs[i]);
    }
  };
  addOutput = (output) => {
    const currentOutputs = this.txBody.outputs();
    currentOutputs.push(this.toCardanoOutput(output));
    this.txBody.setOutputs(currentOutputs);
  };
  toCardanoOutput = (output) => {
    let cardanoOutput = new TransactionOutput(
      toCardanoAddress(output.address),
      toValue(output.amount)
    );
    if (output.datum?.type === "Hash") {
      cardanoOutput.setDatum(
        Datum.newDataHash(
          DatumHash.fromHexBlob(
            HexBlob8(fromBuilderToPlutusData(output.datum.data).hash())
          )
        )
      );
    } else if (output.datum?.type === "Inline") {
      cardanoOutput.setDatum(
        Datum.newInlineData(fromBuilderToPlutusData(output.datum.data))
      );
    } else if (output.datum?.type === "Embedded") {
      const currentWitnessDatum = this.txWitnessSet.plutusData() ?? Serialization6.CborSet.fromCore([], Serialization6.PlutusData.fromCore);
      const currentWitnessDatumValues = [...currentWitnessDatum.values()];
      currentWitnessDatumValues.push(
        fromBuilderToPlutusData(output.datum.data)
      );
      currentWitnessDatum.setValues(currentWitnessDatumValues);
      this.txWitnessSet.setPlutusData(currentWitnessDatum);
    }
    if (output.referenceScript) {
      switch (output.referenceScript.version) {
        case "V1": {
          cardanoOutput.setScriptRef(
            Script.newPlutusV1Script(
              PlutusV1Script.fromCbor(HexBlob8(output.referenceScript.code))
            )
          );
          break;
        }
        case "V2": {
          cardanoOutput.setScriptRef(
            Script.newPlutusV2Script(
              PlutusV2Script.fromCbor(HexBlob8(output.referenceScript.code))
            )
          );
          break;
        }
        case "V3": {
          cardanoOutput.setScriptRef(
            Script.newPlutusV3Script(
              PlutusV3Script.fromCbor(HexBlob8(output.referenceScript.code))
            )
          );
          break;
        }
      }
    }
    return cardanoOutput;
  };
  addAllReferenceInputs = (refInputs) => {
    for (let i = 0; i < refInputs.length; i++) {
      this.addReferenceInput(refInputs[i]);
    }
  };
  addReferenceInput = (refInput) => {
    let referenceInputs = this.txBody.referenceInputs() ?? Serialization6.CborSet.fromCore([], TransactionInput.fromCore);
    let referenceInputsList = [...referenceInputs.values()];
    referenceInputsList.push(
      new TransactionInput(
        TransactionId.fromHexBlob(HexBlob8(refInput.txHash)),
        BigInt(refInput.txIndex)
      )
    );
    referenceInputs.setValues(referenceInputsList);
    this.txBody.setReferenceInputs(referenceInputs);
  };
  addAllMints = (mints) => {
    for (let i2 = 0; i2 < mints.length; i2++) {
      this.addMint(mints[i2]);
    }
    let redeemers = this.txWitnessSet.redeemers() ?? Redeemers.fromCore([]);
    let redeemersList = [...redeemers.values()];
    let i = 0;
    this.mintRedeemers.forEach((redeemer) => {
      const newRedeemer = new Redeemer(
        redeemer.tag(),
        BigInt(i),
        redeemer.data(),
        redeemer.exUnits()
      );
      redeemersList.push(newRedeemer);
      redeemers.setValues(redeemersList);
      i++;
    });
    this.txWitnessSet.setRedeemers(redeemers);
  };
  addMint = (mint) => {
    const currentMint = this.txBody.mint() ?? /* @__PURE__ */ new Map();
    const mintAssetId = mint.policyId + mint.assetName;
    for (const asset of currentMint.keys()) {
      if (asset.toString() == mintAssetId) {
        throw new Error("The same asset is already in the mint field");
      }
    }
    currentMint.set(
      AssetId.fromParts(PolicyId(mint.policyId), AssetName(mint.assetName)),
      BigInt(mint.amount)
    );
    this.txBody.setMint(currentMint);
    if (mint.type === "Native") {
      if (!mint.scriptSource)
        throw new Error("Script source not provided for native script mint");
      const nativeScriptSource = mint.scriptSource;
      if (!nativeScriptSource)
        throw new Error(
          "A script source for a native script was not a native script somehow"
        );
      if (nativeScriptSource.type === "Provided") {
        this.scriptsProvided.add(
          Script.newNativeScript(
            NativeScript.fromCbor(HexBlob8(nativeScriptSource.scriptCode))
          ).toCbor()
        );
      } else if (nativeScriptSource.type === "Inline") {
        this.addSimpleScriptRef(nativeScriptSource);
      }
    } else if (mint.type === "Plutus") {
      if (!mint.scriptSource)
        throw new Error("Script source not provided for plutus script mint");
      const plutusScriptSource = mint.scriptSource;
      if (!plutusScriptSource) {
        throw new Error(
          "A script source for a plutus mint was not plutus script somehow"
        );
      }
      if (!mint.redeemer) {
        throw new Error("A redeemer was not provided for a plutus mint");
      }
      const currentRedeemer = new Redeemer(
        RedeemerTag.Mint,
        BigInt(0),
        fromBuilderToPlutusData(mint.redeemer.data),
        new ExUnits(
          BigInt(mint.redeemer.exUnits.mem),
          BigInt(mint.redeemer.exUnits.steps)
        )
      );
      if (this.mintRedeemers.has(mint.policyId)) {
        if (this.mintRedeemers.get(mint.policyId)?.toCbor() !== currentRedeemer.toCbor()) {
          throw new Error(
            "The same minting policy must have the same redeemer"
          );
        }
      } else {
        this.mintRedeemers.set(mint.policyId, currentRedeemer);
      }
      if (plutusScriptSource.type === "Provided") {
        this.addProvidedPlutusScript(plutusScriptSource.script);
      } else if (plutusScriptSource.type === "Inline") {
        this.addScriptRef(plutusScriptSource);
      }
    }
  };
  addAllCerts = (certs) => {
    for (let i = 0; i < certs.length; i++) {
      this.addCert(certs[i], i);
    }
  };
  addCert = (cert, index) => {
    const currentCerts = this.txBody.certs() ?? Serialization6.CborSet.fromCore([], Serialization6.Certificate.fromCore);
    let currentCertsValues = [...currentCerts.values()];
    currentCertsValues.push(toCardanoCert(cert.certType));
    currentCerts.setValues(currentCertsValues);
    this.txBody.setCerts(currentCerts);
    if (cert.type === "SimpleScriptCertificate") {
      if (!cert.simpleScriptSource)
        throw new Error("Script source not provided for native script cert");
      const nativeScriptSource = cert.simpleScriptSource;
      if (!nativeScriptSource)
        throw new Error(
          "A script source for a native script was not a native script somehow"
        );
      if (nativeScriptSource.type === "Provided") {
        this.scriptsProvided.add(
          Script.newNativeScript(
            NativeScript.fromCbor(HexBlob8(nativeScriptSource.scriptCode))
          ).toCbor()
        );
      } else if (nativeScriptSource.type === "Inline") {
        this.addSimpleScriptRef(nativeScriptSource);
      }
    } else if (cert.type === "ScriptCertificate") {
      if (!cert.scriptSource)
        throw new Error(
          "Script source not provided for plutus script certificate"
        );
      const plutusScriptSource = cert.scriptSource;
      if (!plutusScriptSource) {
        throw new Error(
          "A script source for a plutus certificate was not plutus script somehow"
        );
      }
      if (!cert.redeemer) {
        throw new Error("A redeemer was not provided for a plutus certificate");
      }
      let redeemers = this.txWitnessSet.redeemers() ?? Redeemers.fromCore([]);
      let redeemersList = [...redeemers.values()];
      redeemersList.push(
        new Redeemer(
          RedeemerTag.Cert,
          BigInt(index),
          fromBuilderToPlutusData(cert.redeemer.data),
          new ExUnits(
            BigInt(cert.redeemer.exUnits.mem),
            BigInt(cert.redeemer.exUnits.steps)
          )
        )
      );
      redeemers.setValues(redeemersList);
      this.txWitnessSet.setRedeemers(redeemers);
      if (plutusScriptSource.type === "Provided") {
        this.addProvidedPlutusScript(plutusScriptSource.script);
      } else if (plutusScriptSource.type === "Inline") {
        this.addScriptRef(plutusScriptSource);
      }
    }
  };
  addAllWithdrawals = (withdrawals) => {
    for (let i = 0; i < withdrawals.length; i++) {
      this.addWithdrawal(withdrawals[i], i);
    }
  };
  addWithdrawal = (withdrawal, index) => {
    const currentWithdrawals = this.txBody.withdrawals() ?? /* @__PURE__ */ new Map();
    const address = toCardanoAddress(withdrawal.address);
    const rewardAddress = address.asReward();
    if (!rewardAddress) {
      throw new Error("Failed to parse reward address for withdrawal");
    }
    currentWithdrawals.set(
      RewardAccount.fromCredential(
        rewardAddress.getPaymentCredential(),
        address.getNetworkId()
      ),
      BigInt(withdrawal.coin)
    );
    this.txBody.setWithdrawals(currentWithdrawals);
    if (withdrawal.type === "SimpleScriptWithdrawal") {
      if (!withdrawal.scriptSource)
        throw new Error("Script source not provided for native script cert");
      const nativeScriptSource = withdrawal.scriptSource;
      if (!nativeScriptSource)
        throw new Error(
          "A script source for a native script was not a native script somehow"
        );
      if (nativeScriptSource.type === "Provided") {
        this.scriptsProvided.add(
          Script.newNativeScript(
            NativeScript.fromCbor(HexBlob8(nativeScriptSource.scriptCode))
          ).toCbor()
        );
      } else if (nativeScriptSource.type === "Inline") {
        this.addSimpleScriptRef(nativeScriptSource);
      }
    } else if (withdrawal.type === "ScriptWithdrawal") {
      if (!withdrawal.scriptSource)
        throw new Error(
          "Script source not provided for plutus script certificate"
        );
      const plutusScriptSource = withdrawal.scriptSource;
      if (!plutusScriptSource) {
        throw new Error(
          "A script source for a plutus certificate was not plutus script somehow"
        );
      }
      if (!withdrawal.redeemer) {
        throw new Error("A redeemer was not provided for a plutus certificate");
      }
      let redeemers = this.txWitnessSet.redeemers() ?? Redeemers.fromCore([]);
      let redeemersList = [...redeemers.values()];
      redeemersList.push(
        new Redeemer(
          RedeemerTag.Reward,
          BigInt(index),
          fromBuilderToPlutusData(withdrawal.redeemer.data),
          new ExUnits(
            BigInt(withdrawal.redeemer.exUnits.mem),
            BigInt(withdrawal.redeemer.exUnits.steps)
          )
        )
      );
      redeemers.setValues(redeemersList);
      this.txWitnessSet.setRedeemers(redeemers);
      if (plutusScriptSource.type === "Provided") {
        this.addProvidedPlutusScript(plutusScriptSource.script);
      } else if (plutusScriptSource.type === "Inline") {
        this.addScriptRef(plutusScriptSource);
      }
    }
  };
  addAllCollateralInputs = (collaterals) => {
    for (let i = 0; i < collaterals.length; i++) {
      this.addCollateralInput(
        collaterals[i]
      );
    }
  };
  addCollateralInput = (collateral) => {
    let cardanoTxIn = new TransactionInput(
      TransactionId(collateral.txIn.txHash),
      BigInt(collateral.txIn.txIndex)
    );
    const collateralInputs = this.txBody.collateral() ?? Serialization6.CborSet.fromCore([], TransactionInput.fromCore);
    const collateralInputsList = [
      ...collateralInputs.values()
    ];
    if (collateralInputsList.find((input) => {
      input.index() == cardanoTxIn.index() && input.transactionId == cardanoTxIn.transactionId;
    })) {
      throw new Error("Duplicate input added to tx body");
    }
    collateralInputsList.push(cardanoTxIn);
    collateralInputs.setValues(collateralInputsList);
    const cardanoTxOut = new TransactionOutput(
      toCardanoAddress(collateral.txIn.address),
      toValue(collateral.txIn.amount)
    );
    this.utxoContext.set(cardanoTxIn, cardanoTxOut);
    this.txBody.setCollateral(collateralInputs);
  };
  setValidityInterval = (validity) => {
    if (validity.invalidBefore) {
      this.txBody.setValidityStartInterval(Slot(validity.invalidBefore));
    }
    if (validity.invalidHereafter) {
      this.txBody.setTtl(Slot(validity.invalidHereafter));
    }
  };
  addAllRequiredSignatures = (requiredSignatures) => {
    const requiredSigners = this.txBody.requiredSigners() ?? Serialization6.CborSet.fromCore([], Serialization6.Hash.fromCore);
    let requiredSignerValues = [...requiredSigners.values()];
    for (const requiredSigner of requiredSignatures) {
      requiredSignerValues.push(
        Serialization6.Hash.fromCore(Ed25519KeyHashHex2(requiredSigner))
      );
    }
    requiredSigners.setValues(requiredSignerValues);
    this.txBody.setRequiredSigners(requiredSigners);
  };
  addMetadata = (metadata) => {
    this.txAuxilliaryData.setMetadata(
      new Serialization6.GeneralTransactionMetadata(
        toCardanoMetadataMap(metadata)
      )
    );
  };
  buildWitnessSet = () => {
    let nativeScripts = this.txWitnessSet.nativeScripts() ?? Serialization6.CborSet.fromCore([], NativeScript.fromCore);
    let v1Scripts = this.txWitnessSet.plutusV1Scripts() ?? Serialization6.CborSet.fromCore([], PlutusV1Script.fromCore);
    let v2Scripts = this.txWitnessSet.plutusV2Scripts() ?? Serialization6.CborSet.fromCore([], PlutusV2Script.fromCore);
    let v3Scripts = this.txWitnessSet.plutusV3Scripts() ?? Serialization6.CborSet.fromCore([], PlutusV3Script.fromCore);
    this.scriptsProvided.forEach((scriptHex) => {
      const script = Script.fromCbor(HexBlob8(scriptHex));
      if (script.asNative() !== void 0) {
        let nativeScriptsList = [...nativeScripts.values()];
        nativeScriptsList.push(script.asNative());
        nativeScripts.setValues(nativeScriptsList);
      } else if (script.asPlutusV1() !== void 0) {
        let v1ScriptsList = [...v1Scripts.values()];
        v1ScriptsList.push(script.asPlutusV1());
        v1Scripts.setValues(v1ScriptsList);
      } else if (script.asPlutusV2() !== void 0) {
        let v2ScriptsList = [...v2Scripts.values()];
        v2ScriptsList.push(script.asPlutusV2());
        v2Scripts.setValues(v2ScriptsList);
      } else if (script.asPlutusV3() !== void 0) {
        let v3ScriptsList = [...v3Scripts.values()];
        v3ScriptsList.push(script.asPlutusV3());
        v3Scripts.setValues(v3ScriptsList);
      }
      this.txWitnessSet.setNativeScripts(nativeScripts);
      this.txWitnessSet.setPlutusV1Scripts(v1Scripts);
      this.txWitnessSet.setPlutusV2Scripts(v2Scripts);
      this.txWitnessSet.setPlutusV3Scripts(v3Scripts);
    });
    let datums = this.txWitnessSet.plutusData() ?? Serialization6.CborSet.fromCore([], PlutusData.fromCore);
    let datumsList = [...datums.values()];
    this.datumsProvided.forEach((datum) => {
      datumsList.push(datum);
    });
    datums.setValues(datumsList);
    this.txWitnessSet.setPlutusData(datums);
    let costModelV1 = Serialization6.CostModel.newPlutusV1(
      DEFAULT_V1_COST_MODEL_LIST
    );
    let costModelV2 = Serialization6.CostModel.newPlutusV2(
      DEFAULT_V2_COST_MODEL_LIST
    );
    let costModelV3 = Serialization6.CostModel.newPlutusV3(
      DEFAULT_V3_COST_MODEL_LIST
    );
    let costModels = new Serialization6.Costmdls();
    if (this.usedLanguages[PlutusLanguageVersion.V1]) {
      costModels.insert(costModelV1);
    }
    if (this.usedLanguages[PlutusLanguageVersion.V2]) {
      costModels.insert(costModelV2);
    }
    if (this.usedLanguages[PlutusLanguageVersion.V3]) {
      costModels.insert(costModelV3);
    }
    const redeemers = this.txWitnessSet.redeemers() ?? Redeemers.fromCore([]);
    let scriptDataHash = hashScriptData(
      costModels,
      redeemers.size() > 0 ? [...redeemers.values()] : void 0,
      datums.size() > 0 ? [...datums.values()] : void 0
    );
    if (scriptDataHash) {
      this.txBody.setScriptDataHash(scriptDataHash);
    }
    let auxiliaryDataHash = computeAuxiliaryDataHash(
      this.txAuxilliaryData.toCore()
    );
    if (auxiliaryDataHash) {
      this.txBody.setAuxiliaryDataHash(auxiliaryDataHash);
    }
  };
  removeInputRefInputOverlap = () => {
    let refInputsValues = [];
    const inputs = this.txBody.inputs()?.values();
    if (this.txBody.referenceInputs()) {
      const currentRefInputValues = this.txBody.referenceInputs().values();
      currentRefInputValues.forEach((refInput) => {
        let found = false;
        for (let i = 0; i < inputs.length; i++) {
          if (refInput.toCbor() === inputs[i].toCbor()) {
            found = true;
          }
        }
        if (!found) {
          refInputsValues.push(refInput);
        }
      });
      this.txBody.setReferenceInputs(
        Serialization6.CborSet.fromCore(
          refInputsValues.map((input) => input.toCore()),
          TransactionInput.fromCore
        )
      );
    }
  };
  balanceTx = (changeAddress) => {
    if (changeAddress === "") {
      throw new Error("Can't balance tx without a change address");
    }
    const inputs = this.txBody.inputs().values();
    let remainingValue = new Value(BigInt(0));
    for (let i = 0; i < inputs.length; i++) {
      let input = inputs[i];
      if (!input) {
        throw new Error("Invalid input found");
      }
      const output = this.utxoContext.get(input);
      if (!output) {
        throw new Error(`Unable to resolve input: ${input.toCbor()}`);
      }
      remainingValue = mergeValue(remainingValue, output.amount());
    }
    const withdrawals = this.txBody.withdrawals();
    if (withdrawals) {
      withdrawals.forEach((coin) => {
        remainingValue = mergeValue(remainingValue, new Value(coin));
      });
    }
    remainingValue = mergeValue(
      remainingValue,
      new Value(BigInt(0), this.txBody.mint())
    );
    const currentOutputs = this.txBody.outputs();
    for (let i = 0; i < currentOutputs.length; i++) {
      let output = currentOutputs.at(i);
      if (output) {
        remainingValue = subValue(remainingValue, output.amount());
      }
    }
    const certs = this.txBody.certs();
    if (certs) {
      certs.values().forEach((cert) => {
        switch (cert.toCore().__typename) {
          case CertificateType.StakeRegistration: {
            remainingValue = subValue(
              remainingValue,
              new Value(BigInt(this.protocolParams.keyDeposit))
            );
            break;
          }
          case CertificateType.StakeDeregistration: {
            remainingValue = mergeValue(
              remainingValue,
              new Value(BigInt(this.protocolParams.keyDeposit))
            );
            break;
          }
          case CertificateType.Registration: {
            remainingValue = subValue(
              remainingValue,
              new Value(BigInt(cert.asRegistrationCert()?.deposit() ?? 0))
            );
            break;
          }
          case CertificateType.Unregistration: {
            remainingValue = mergeValue(
              remainingValue,
              new Value(BigInt(cert.asUnregistrationCert()?.deposit() ?? 0))
            );
            break;
          }
          case CertificateType.PoolRegistration: {
            remainingValue = subValue(
              remainingValue,
              new Value(BigInt(this.protocolParams.poolDeposit))
            );
            break;
          }
          case CertificateType.PoolRetirement: {
            remainingValue = mergeValue(
              remainingValue,
              new Value(BigInt(this.protocolParams.poolDeposit))
            );
            break;
          }
          case CertificateType.RegisterDelegateRepresentative: {
            remainingValue = subValue(
              remainingValue,
              new Value(
                BigInt(
                  cert.asRegisterDelegateRepresentativeCert()?.deposit() ?? 0
                )
              )
            );
            break;
          }
          case CertificateType.UnregisterDelegateRepresentative: {
            remainingValue = mergeValue(
              remainingValue,
              new Value(
                BigInt(
                  cert.asUnregisterDelegateRepresentativeCert()?.deposit() ?? 0
                )
              )
            );
            break;
          }
          case CertificateType.StakeRegistrationDelegation: {
            remainingValue = subValue(
              remainingValue,
              new Value(
                BigInt(
                  cert.asStakeRegistrationDelegationCert()?.deposit() ?? 0
                )
              )
            );
            break;
          }
          case CertificateType.StakeVoteRegistrationDelegation: {
            remainingValue = subValue(
              remainingValue,
              new Value(
                BigInt(
                  cert.asStakeVoteRegistrationDelegationCert()?.deposit() ?? 0
                )
              )
            );
            break;
          }
        }
      });
    }
    if (remainingValue.coin() < 0 || !empty(negatives(remainingValue))) {
      throw new Error(`Not enough funds to satisfy outputs`);
    }
    currentOutputs.push(
      new TransactionOutput(toCardanoAddress(changeAddress), remainingValue)
    );
    this.txBody.setOutputs(currentOutputs);
    this.txBody.setFee(BigInt("10000000"));
    const numberOfRequiredWitnesses = this.countNumberOfRequiredWitnesses();
    const dummyTx = this.createDummyTx(numberOfRequiredWitnesses);
    const fee = calculateFees(
      this.protocolParams.minFeeA,
      this.protocolParams.minFeeB,
      this.protocolParams.minFeeRefScriptCostPerByte,
      this.protocolParams.priceMem,
      this.protocolParams.priceStep,
      dummyTx,
      this.refScriptSize
    );
    this.txBody.setFee(fee);
    const changeOutput = currentOutputs.pop();
    if (!changeOutput) {
      throw new Error(
        "Somehow the output length was 0 after attempting to calculate fees"
      );
    }
    if (changeOutput.amount().coin() - fee > 0) {
      changeOutput.amount().setCoin(changeOutput.amount().coin() - fee);
      currentOutputs.push(changeOutput);
    } else if (changeOutput.amount().coin() - fee < 0) {
      throw new Error(
        "There was enough inputs to cover outputs, but not enough to cover fees"
      );
    }
    this.txBody.setOutputs(currentOutputs);
  };
  createDummyTx = (numberOfRequiredWitnesses) => {
    let dummyWitnessSet = TransactionWitnessSet.fromCbor(
      HexBlob8(this.txWitnessSet.toCbor())
    );
    const dummyVkeyWitnesses = [];
    for (let i = 0; i < numberOfRequiredWitnesses; i++) {
      dummyVkeyWitnesses.push([
        Ed25519PublicKeyHex2(String(i).repeat(64)),
        Ed25519SignatureHex2(String(i).repeat(128))
      ]);
    }
    dummyWitnessSet.setVkeys(
      Serialization6.CborSet.fromCore(dummyVkeyWitnesses, VkeyWitness.fromCore)
    );
    return new Transaction(this.txBody, dummyWitnessSet, this.txAuxilliaryData);
  };
  addScriptRef = (scriptSource) => {
    if (scriptSource.type !== "Inline") {
      return;
    }
    let referenceInputs = this.txBody.referenceInputs() ?? Serialization6.CborSet.fromCore([], TransactionInput.fromCore);
    let referenceInputsList = [...referenceInputs.values()];
    referenceInputsList.push(
      new TransactionInput(
        TransactionId(scriptSource.txHash),
        BigInt(scriptSource.txIndex)
      )
    );
    referenceInputs.setValues(referenceInputsList);
    this.txBody.setReferenceInputs(referenceInputs);
    switch (scriptSource.version) {
      case "V1": {
        this.usedLanguages[PlutusLanguageVersion.V1] = true;
        break;
      }
      case "V2": {
        this.usedLanguages[PlutusLanguageVersion.V2] = true;
        break;
      }
      case "V3": {
        this.usedLanguages[PlutusLanguageVersion.V3] = true;
        break;
      }
    }
    if (scriptSource.scriptSize) {
      this.refScriptSize += Number(scriptSource.scriptSize);
    } else {
      throw new Error(
        "A reference script was used without providing its size, this must be provided as fee calculations are based on it"
      );
    }
  };
  addSimpleScriptRef = (simpleScriptSource) => {
    if (simpleScriptSource.type !== "Inline") {
      return;
    }
    let referenceInputs = this.txBody.referenceInputs() ?? Serialization6.CborSet.fromCore([], TransactionInput.fromCore);
    let referenceInputsList = [...referenceInputs.values()];
    referenceInputsList.push(
      new TransactionInput(
        TransactionId(simpleScriptSource.txHash),
        BigInt(simpleScriptSource.txIndex)
      )
    );
    if (simpleScriptSource.scriptSize) {
      this.refScriptSize += Number(simpleScriptSource.scriptSize);
    } else {
      throw new Error(
        "A reference script was used without providing its size, this must be provided as fee calculations are based on it"
      );
    }
    referenceInputs.setValues(referenceInputsList);
    this.txBody.setReferenceInputs(referenceInputs);
  };
  countNumberOfRequiredWitnesses() {
    let requiredWitnesses = /* @__PURE__ */ new Set();
    const inputs = this.txBody.inputs().values();
    for (let i = 0; i < inputs.length; i++) {
      const input = inputs[i];
      const addressPaymentPart = this.utxoContext.get(input)?.address().getProps().paymentPart;
      if (addressPaymentPart?.type === 0) {
        requiredWitnesses.add(addressPaymentPart.hash);
      }
    }
    const collateralInputs = this.txBody.collateral()?.values();
    if (collateralInputs) {
      for (let i = 0; i < collateralInputs?.length; i++) {
        const collateralInput = collateralInputs[i];
        const addressPaymentPart = this.utxoContext.get(collateralInput)?.address().getProps().paymentPart;
        if (addressPaymentPart?.type === 0) {
          requiredWitnesses.add(addressPaymentPart.hash);
        }
      }
    }
    const withdrawalKeys = this.txBody.withdrawals()?.keys();
    if (withdrawalKeys) {
      for (let withdrawalKey of withdrawalKeys) {
        requiredWitnesses.add(RewardAccount.toHash(withdrawalKey));
      }
    }
    const certs = this.txBody.certs()?.values();
    if (certs) {
      for (let cert of certs) {
        const coreCert = cert.toCore();
        switch (coreCert.__typename) {
          case CertificateType.StakeRegistration: {
            requiredWitnesses.add(coreCert.stakeCredential.hash);
            break;
          }
          case CertificateType.StakeDeregistration: {
            requiredWitnesses.add(coreCert.stakeCredential.hash);
            break;
          }
          case CertificateType.PoolRegistration: {
            for (let owner of coreCert.poolParameters.owners) {
              requiredWitnesses.add(RewardAccount.toHash(owner));
            }
            requiredWitnesses.add(PoolId.toKeyHash(coreCert.poolParameters.id));
            break;
          }
          case CertificateType.PoolRetirement: {
            requiredWitnesses.add(PoolId.toKeyHash(coreCert.poolId));
            break;
          }
          case CertificateType.StakeDelegation: {
            requiredWitnesses.add(coreCert.stakeCredential.hash);
            break;
          }
          case CertificateType.MIR:
            break;
          case CertificateType.GenesisKeyDelegation: {
            requiredWitnesses.add(coreCert.genesisDelegateHash);
            break;
          }
          case CertificateType.Registration: {
            requiredWitnesses.add(coreCert.stakeCredential.hash);
            break;
          }
          case CertificateType.Unregistration: {
            requiredWitnesses.add(coreCert.stakeCredential.hash);
            break;
          }
          case CertificateType.VoteDelegation: {
            requiredWitnesses.add(coreCert.stakeCredential.hash);
            break;
          }
          case CertificateType.StakeVoteDelegation: {
            requiredWitnesses.add(coreCert.stakeCredential.hash);
            break;
          }
          case CertificateType.StakeRegistrationDelegation: {
            requiredWitnesses.add(coreCert.stakeCredential.hash);
            break;
          }
          case CertificateType.VoteRegistrationDelegation: {
            requiredWitnesses.add(coreCert.stakeCredential.hash);
            break;
          }
          case CertificateType.StakeVoteRegistrationDelegation: {
            requiredWitnesses.add(coreCert.stakeCredential.hash);
            break;
          }
          case CertificateType.AuthorizeCommitteeHot: {
            requiredWitnesses.add(coreCert.hotCredential.hash);
            break;
          }
          case CertificateType.ResignCommitteeCold: {
            requiredWitnesses.add(coreCert.coldCredential.hash);
            break;
          }
          case CertificateType.RegisterDelegateRepresentative: {
            requiredWitnesses.add(coreCert.dRepCredential.hash);
            break;
          }
          case CertificateType.UnregisterDelegateRepresentative: {
            requiredWitnesses.add(coreCert.dRepCredential.hash);
            break;
          }
          case CertificateType.UpdateDelegateRepresentative: {
            requiredWitnesses.add(coreCert.dRepCredential.hash);
            break;
          }
        }
      }
    }
    for (const scriptHex of this.scriptsProvided) {
      const script = Script.fromCbor(HexBlob8(scriptHex));
      let nativeScript = script.asNative();
      if (nativeScript) {
        this.addKeyHashesFromNativeScript(nativeScript, requiredWitnesses);
      }
    }
    const requiredSigners = this.txBody.requiredSigners()?.values();
    if (requiredSigners) {
      for (let i = 0; i < requiredSigners.length; i++) {
        requiredWitnesses.add(requiredSigners[i].toCbor());
      }
    }
    return requiredWitnesses.size;
  }
  addKeyHashesFromNativeScript(script, keyHashes) {
    const scriptCore = script.toCore();
    switch (scriptCore.kind) {
      case RequireSignature: {
        keyHashes.add(scriptCore.keyHash);
        break;
      }
      case RequireTimeAfter: {
        break;
      }
      case RequireTimeBefore: {
        break;
      }
      case RequireAllOf: {
        for (const innerScript of scriptCore.scripts) {
          this.addKeyHashesFromNativeScript(
            NativeScript.fromCore(innerScript),
            keyHashes
          );
        }
        break;
      }
      case RequireAnyOf: {
        for (const innerScript of scriptCore.scripts) {
          this.addKeyHashesFromNativeScript(
            NativeScript.fromCore(innerScript),
            keyHashes
          );
        }
        break;
      }
      case RequireNOf: {
        for (const innerScript of scriptCore.scripts) {
          this.addKeyHashesFromNativeScript(
            NativeScript.fromCore(innerScript),
            keyHashes
          );
        }
        break;
      }
    }
    return keyHashes;
  }
  addProvidedPlutusScript = (script) => {
    switch (script.version) {
      case "V1": {
        this.scriptsProvided.add(
          Script.newPlutusV1Script(
            PlutusV1Script.fromCbor(HexBlob8(script.code))
          ).toCbor()
        );
        this.usedLanguages[PlutusLanguageVersion.V1] = true;
        break;
      }
      case "V2": {
        this.scriptsProvided.add(
          Script.newPlutusV2Script(
            PlutusV2Script.fromCbor(HexBlob8(script.code))
          ).toCbor()
        );
        this.usedLanguages[PlutusLanguageVersion.V2] = true;
        break;
      }
      case "V3": {
        this.scriptsProvided.add(
          Script.newPlutusV3Script(
            PlutusV3Script.fromCbor(HexBlob8(script.code))
          ).toCbor()
        );
        this.usedLanguages[PlutusLanguageVersion.V3] = true;
        break;
      }
    }
  };
};

// src/plutus-tools/index.ts
import { Cbor as Cbor2, CborBytes as CborBytes2 } from "@harmoniclabs/cbor";
import { dataFromCbor } from "@harmoniclabs/plutus-data";
import {
  Application,
  encodeUPLC,
  parseUPLC,
  UPLCConst,
  UPLCProgram
} from "@harmoniclabs/uplc";
var supportedPlutusCoreVersions = [
  {
    version: [1, 0, 0],
    language: "Plutus V1"
  },
  {
    version: [1, 1, 0],
    language: "Plutus V3"
  }
];
var applyArgsToPlutusScript = (args, program, outputEncoding) => {
  const purePlutusBytes = getPurePlutusBytes(program);
  const parsedProgram = parseUPLC(purePlutusBytes, "flat");
  const decodedArgs = args.map((arg) => dataFromCbor(arg));
  let body = parsedProgram.body;
  for (const plutusData of decodedArgs) {
    const argTerm = UPLCConst.data(plutusData);
    body = new Application(body, argTerm);
  }
  const encodedProgram = new UPLCProgram(parsedProgram.version, body);
  const newPlutusScriptBytes = encodeUPLC(encodedProgram).toBuffer().buffer;
  return applyEncoding(newPlutusScriptBytes, outputEncoding);
};
var normalizePlutusScript = (plutusScript, encoding) => {
  const bytes = Buffer.from(plutusScript, "hex");
  const purePlutusBytes = getPurePlutusBytes(bytes);
  const normalizedBytes = applyEncoding(purePlutusBytes, encoding);
  return Buffer.from(normalizedBytes).toString("hex");
};
var hasSupportedPlutusVersion = (plutusScript) => {
  if (plutusScript.length < 3) {
    return false;
  }
  const version = [plutusScript[0], plutusScript[1], plutusScript[2]];
  return supportedPlutusCoreVersions.some((supportedVersion) => {
    return supportedVersion.version[0] === version[0] && supportedVersion.version[1] === version[1] && supportedVersion.version[2] === version[2];
  });
};
var getPurePlutusBytes = (plutusScript) => {
  let unwrappedScript = plutusScript;
  let length = 0;
  try {
    while (unwrappedScript.length >= 3 && length != unwrappedScript.length) {
      length = unwrappedScript.length;
      if (hasSupportedPlutusVersion(unwrappedScript)) {
        return unwrappedScript;
      }
      const cbor = Cbor2.parse(unwrappedScript);
      if (cbor instanceof CborBytes2) {
        unwrappedScript = cbor.bytes;
      } else {
        break;
      }
    }
  } catch (error) {
    console.error("Error parsing Plutus script:", error);
  }
  if (hasSupportedPlutusVersion(unwrappedScript)) {
    return unwrappedScript;
  }
  throw new Error("Unsupported Plutus version or invalid Plutus script bytes");
};
var applyCborEncoding = (plutusScript) => {
  return Cbor2.encode(new CborBytes2(plutusScript)).toBuffer();
};
var applyEncoding = (plutusScript, outputEncoding) => {
  switch (outputEncoding) {
    case "SingleCBOR":
      return applyCborEncoding(plutusScript);
    case "DoubleCBOR":
      return applyCborEncoding(applyCborEncoding(plutusScript));
    case "PurePlutusScriptBytes":
      return plutusScript;
    default:
      return applyCborEncoding(plutusScript);
  }
};
var applyParamsToScript = (rawScript, params, type = "Mesh") => {
  let plutusParams = [];
  switch (type) {
    case "JSON":
      params.forEach((param) => {
        plutusParams.push(
          fromBuilderToPlutusData({
            type: "JSON",
            content: param
          })
        );
      });
      break;
    case "CBOR":
      params.forEach((param) => {
        plutusParams.push(
          fromBuilderToPlutusData({
            type: "CBOR",
            content: param
          })
        );
      });
      break;
    case "Mesh":
      params.forEach((param) => {
        plutusParams.push(
          fromBuilderToPlutusData({
            type: "Mesh",
            content: param
          })
        );
      });
      break;
  }
  const byteParams = plutusParams.map((param) => {
    return Buffer.from(param.toCbor(), "hex");
  });
  const scriptHex = Buffer.from(
    applyArgsToPlutusScript(
      byteParams,
      Buffer.from(rawScript, "hex"),
      "DoubleCBOR"
    )
  ).toString("hex");
  return scriptHex;
};

// src/index.ts
import * as CardanoSDKUtil from "@cardano-sdk/util";
import * as Crypto2 from "@cardano-sdk/crypto";
import * as CardanoSDK from "@cardano-sdk/core";
export {
  Address,
  AddressType,
  AssetFingerprint,
  AssetId,
  AssetName,
  AuxilliaryData,
  BaseAddress,
  Bip32PrivateKey2 as Bip32PrivateKey,
  Bip32PrivateKeyHex2 as Bip32PrivateKeyHex,
  Cardano5 as Cardano,
  CardanoSDK,
  CardanoSDKSerializer,
  CardanoSDKUtil,
  CborSet,
  CborWriter,
  CertIndex,
  Certificate,
  CertificateType,
  ConstrPlutusData,
  CoseSign1,
  CostModel,
  Costmdls,
  Credential,
  CredentialType,
  Crypto2 as Crypto,
  DRep,
  DRepID,
  Datum,
  DatumHash,
  DatumKind,
  Ed25519KeyHash2 as Ed25519KeyHash,
  Ed25519KeyHashHex2 as Ed25519KeyHashHex,
  Ed25519PrivateExtendedKeyHex,
  Ed25519PrivateNormalKeyHex,
  Ed25519PublicKey2 as Ed25519PublicKey,
  Ed25519PublicKeyHex2 as Ed25519PublicKeyHex,
  Ed25519Signature2 as Ed25519Signature,
  Ed25519SignatureHex2 as Ed25519SignatureHex,
  EnterpriseAddress,
  ExUnits,
  Hash,
  Hash28ByteBase162 as Hash28ByteBase16,
  Hash32ByteBase162 as Hash32ByteBase16,
  MetadatumList,
  MetadatumMap,
  NativeScript,
  NetworkId,
  PaymentAddress,
  PlutusData,
  PlutusDataKind,
  PlutusLanguageVersion,
  PlutusList,
  PlutusMap,
  PlutusV1Script,
  PlutusV2Script,
  PlutusV3Script,
  PointerAddress,
  PolicyId,
  PoolId,
  Redeemer,
  RedeemerPurpose,
  RedeemerTag,
  Redeemers,
  RequireAllOf,
  RequireAnyOf,
  RequireNOf,
  RequireSignature,
  RequireTimeAfter,
  RequireTimeBefore,
  RewardAccount,
  RewardAddress,
  Script,
  ScriptHash,
  ScriptPubkey,
  Serialization7 as Serialization,
  Slot,
  StakeCredentialStatus,
  StakeDelegation,
  StakeRegistration,
  StricaBip32PrivateKey,
  StricaBip32PrivateKey as StricaBip32PrivateKeyType,
  StricaBip32PublicKey,
  StricaBip32PublicKey as StricaBip32PublicKeyType,
  StricaDecoder,
  StricaEncoder,
  StricaPrivateKey,
  StricaPrivateKey as StricaPrivateKeyType,
  StricaPublicKey,
  StricaPublicKey as StricaPublicKeyType,
  Transaction,
  TransactionBody,
  TransactionId,
  TransactionInput,
  TransactionMetadatum,
  TransactionOutput,
  TransactionUnspentOutput,
  TransactionWitnessSet,
  TxIndex,
  Value,
  VkeyWitness,
  VrfVkBech32,
  addrBech32ToPlutusDataHex,
  addrBech32ToPlutusDataObj,
  addressToBech32,
  applyEncoding,
  applyParamsToScript,
  assetTypes,
  blake2b2 as blake2b,
  buildBaseAddress,
  buildBip32PrivateKey,
  buildDRepID,
  buildEnterpriseAddress,
  buildKeys,
  buildRewardAddress,
  buildScriptPubkey,
  bytesToHex,
  checkSignature,
  computeAuxiliaryDataHash,
  deserializeAddress,
  deserializeBech32Address,
  deserializeDataHash,
  deserializeEd25519KeyHash,
  deserializeNativeScript,
  deserializePlutusData,
  deserializePlutusScript,
  deserializeScriptHash,
  deserializeScriptRef,
  deserializeTx,
  deserializeTxHash,
  deserializeTxUnspentOutput,
  deserializeValue,
  empty,
  fromBuilderToPlutusData,
  fromJsonToPlutusData,
  fromNativeScript,
  fromPlutusDataToJson,
  fromScriptRef,
  fromTxUnspentOutput,
  fromValue,
  generateNonce,
  getCoseKeyFromPublicKey,
  getDRepIds,
  getPublicKeyFromCoseKey,
  hexToBech32,
  hexToBytes,
  keyHashToRewardAddress,
  mergeValue,
  negateValue,
  negatives,
  normalizePlutusScript,
  parseDatumCbor,
  parseInlineDatum,
  resolveDataHash,
  resolveEd25519KeyHash,
  resolveNativeScriptAddress,
  resolveNativeScriptHash,
  resolvePaymentKeyHash,
  resolvePlutusScriptAddress,
  resolvePlutusScriptHash,
  resolvePoolId,
  resolvePrivateKey,
  resolveRewardAddress,
  resolveScriptHashDRepId,
  resolveScriptRef,
  resolveStakeKeyHash,
  resolveTxHash,
  scriptHashToBech32,
  scriptHashToRewardAddress,
  serializeAddressObj,
  serializePlutusAddressToBech32,
  serialzeAddress,
  signData,
  subValue,
  toAddress,
  toBaseAddress,
  toCardanoAddress,
  toDRep,
  toEnterpriseAddress,
  toNativeScript,
  toPlutusData,
  toRewardAddress,
  toScriptRef,
  toTxUnspentOutput,
  toValue,
  utf8ToBytes,
  utf8ToHex,
  v2ScriptToBech32
};
